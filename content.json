{"pages":[],"posts":[{"title":"CSS - CSS Reset vs CSS Normalize","text":"CSS Reset因近年來各家瀏覽器陸續出現，更有新舊版本的差異，所以會產生不同的預設樣式，如默認行高，邊距和各元素字體大小等方面的不一致，一個統一的預設樣式開始變得越來越重要。 最簡單粗暴的做法就是直接把所有的預設樣式強制歸 0，比如： 123456* { margin: 0; padding: 0; border: 0; font-size: 100%;}但是通用符號會匹配所有的標籤，如果開發的是大型網站，會大大加重網頁渲染時間，所以最好還是只對需要的標籤做修改。 CSS-Tricks 調查最多人使用的 Eric Meyer 的版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, font, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td { margin: 0; padding: 0; border: 0; outline: 0; font-weight: inherit; font-style: inherit; font-size: 100%; font-family: inherit; vertical-align: baseline;}/* remember to define focus styles! */:focus { outline: 0;}body { line-height: 1; color: black; background: white;}ol, ul { list-style: none;}/* tables still need &apos;cellspacing=&quot;0&quot;&apos; in the markup */table { border-collapse: separate; border-spacing: 0;}caption, th, td { text-align: left; font-weight: normal;}blockquote:before, blockquote:after,q:before, q:after { content: &quot;&quot;;}blockquote, q { quotes: &quot;&quot; &quot;&quot;;}https://meyerweb.com/eric/tools/css/reset/ CSS Normalize因為 reset.css 重置了各個瀏覽器的樣式設定，使得有些有用、常用標籤的默認樣式必須要重新設定，因為這個問題，導致了 Normalize.css 的出現。 Normalize 最大的特色就是保留原本預設 HTML 標籤的樣式，僅針對不同瀏覽器與各版本間不相容的標籤進行些微調整。 Normalize.css 的目標： 保留有用的瀏覽器默認設置，而不是將其刪除。為廣泛的 HTML 元素提供一般化的樣式。修正瀏覽器的 Bug 與不一致。透過微妙的改善提高可用性。有詳細的文檔來解釋代碼。(每個樣式都有註解是處理什麼問題。) http://nicolasgallagher.com/about-normalize-css/","link":"/2020/04/23/CSS-CSS-Reset-vs-CSS-normalize/"},{"title":"Front-end - 前端中的 MVVM 與 Vue.js","text":"MVVM（Model–view–viewmodel）是一種軟體架構模式，其核心是提供對 View 和 View Model 的雙向數據綁定，這使得 View Model 的狀態改變可以自動傳遞給 View，這就是所謂的數據雙向綁定。 MVVM？ 為什麼需要使用它？討論 MVVM 前，先稍微暸解 MVC 架構 Model 就是數據View 把數據以某種方式呈現給用戶Controller 接收並處理來自用戶的請求，並將 Model 返回給用戶 在 HTML5 出現前，MVC 做為 Web 應用的最佳實踐是沒問題的，這是因為 Web 應用的 View 層相對來說比較簡單，前端所需要的數據在後端基本上都可以處理好，View 層主要是做一下展示，那時候提倡的是 Controller 來處理複雜的業務邏輯，所以 View 層相對來說比較輕量。 在 HTML5 出現後，View 層所做的事，就不僅僅是簡單的數據展示了，要管理數據，管理用戶操作的各種狀態，還要處理移動設備上用戶各種操作行為等等。因此，前端自己也需要一個類似於 MVC 的框架來管理這些複雜的邏輯，使開發更加高效。 此時的 MVC 架構在前端開發中變成以下： Model 管理數據View UI 布局，展示數據Controller 響應用戶操作，並將 Model 更新到 View 上 這種 MVC 架構模式對於基礎的應用來看起是OK的，更是符合軟體架構的分層思想。 但實際上，隨著 H5 的不斷發展，人們更希望使用 H5 開發的應用能和 Native 媲美，或者接近於原生 App 體驗效果，於是前端應用的複雜程度已不同往日，今非昔比。這時前端就暴露了三個重要的痛點問題： 開發者在代碼中大量調用相同的 DOM API, 處理繁瑣 ，操作冗餘，使得代碼難以維護。 大量的 DOM 操作使頁面渲染性能降低，加載速度變慢，影響用戶體驗。 當 Model 頻繁發生變化，開發者需要主動更新到 View；當用戶的操作導致 Model 發生變化，開發者同樣需要將變化的數據同步到 Model 中， 這樣的工作不僅繁瑣，而且很難維護複雜多變的數據狀態。 MVVM 的出現，完美的解決了以上三個問題MVVM 由 Model,View,ViewModel 三部分組成，Model 層代表數據模型，也可以在 Model 中定義數據修改和操作的業務邏輯；View 代表 UI 組件，它負責將數據模型轉化成 UI 展現出來，ViewModel 是一個同步 View 和 Model的對象。 在MVVM架構下，View 和 Model 之間並沒有直接的聯繫，而是通過 ViewModel 進行交互，Model 和 ViewModel 之間的交互是雙向的， 因此View 數據的變化會同步到 Model 中，而 Model 數據的變化也會立即反應到 View 上。 ViewModel 通過雙向數據綁定把 View 層和 Model 層連接了起來，而 View 和 Model 之間的同步工作完全是自動的，無需人為干涉，因此開發者只需關注業務邏輯，不需要手動操作 DOM,不需要關注數據狀態的同步問題，複雜的數據狀態維護完全由 MVVM 來統一管理。 Vue.js 的細節Vue.js 可以說是前端框架中 MVVM 架構的最佳實踐，專注於 MVVM 中的 ViewModel，不僅做到了數據雙向綁定，而且也是一款相對來比較輕量級的 JS 庫，API 簡潔，很容易上手。 下面簡單了解一下 Vue.js 關於雙向綁定的一些實現細節： Vue.js 採用的是 Object.defineProperty 的 getter 和 setter，並結合觀察者模式來實現數據綁定的。當把一個普通 Javascript 對象傳給 Vue 實例來作為它的 data 選項時，Vue 將遍歷它的屬性，用 Object.defineProperty 將它們轉為 getter/setter。用戶看不到 getter/setters，但是在內部它們讓 Vue 追蹤依賴，在屬性被訪問和修改時通知變化。 Observer 數據監聽器，能夠對數據對象的所有屬性進行監聽，如有變動可拿到最新值並通知訂閱者，內部採用Object.defineProperty的getter和setter來實現Compile 指令解析器，它的作用對每個元素節點的指令進行掃描和解析，根據指令模板替換數據，以及綁定相應的更新函數Watcher 訂閱者， 作為連接 Observer 和 Compile 的橋樑，能夠訂閱並收到每個屬性變動的通知，執行指令綁定的相應回調函數Dep 消息訂閱器，內部維護了一個數組，用來收集訂閱者（Watcher），數據變動觸發notify 函數，再調用訂閱者的 update 方法 當執行 new Vue 時，Vue 就進入了初始化階段，一方面 Vue 會遍歷 data 選項中的屬性，並用 Object.defineProperty 將它們轉為 getter/setter，實現數據變化監聽功能；另一方面，Vue 的指令編譯器 Compile 對元素節點的指令進行掃描和解析，初始化視圖，並訂閱 Watcher 來更新視圖， 此時 Watcher 會將自己添加到消息訂閱器中(dep),初始化完畢。 當數據發生變化時，Observer 中的 setter方 法被觸發，setter 會立即調用 Dep.notify，Dep 開始遍歷所有的訂閱者，並調用訂閱者的 update 方法，訂閱者收到通知後對視圖進行相應的更新，完成一次數據綁定。 原文網址：https://www.cnblogs.com/onepixel/p/6034307.html","link":"/2020/04/21/Vue.js%20-%20MVVM/"},{"title":"CSS-BEM and 7-1pattern","text":"BEM在網頁前端開發時，有時候我們會遇到一些 class 命名的問題，舉幾個例子： 比如頁面上有兩個頭像 avator，一個在 navbar 上，另外一個在文章標題旁邊，功能都是秀出頭像，只是樣式上的不同，class 就沒辦法都取為 avator。 另外一個問題，在撰寫 style 時，有時候需要來回對照現在寫的 \bclass 是在哪一個父元素下面，沒辦法看到 class 就知道他在網頁的哪個部分。 在使用 Sass 時，有一個很棒的地方，就是它的巢狀結構，有沒有辦法讓他更簡潔，又一目瞭然。 有沒有一個 class 命名標準，可以一次解決上述的問題，有，那就是 BEM 了！ BEM Block Element Modifier","link":"/2020/04/28/CSS-BEM-and-7-1pattern/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"}],"categories":[{"name":"front-end","slug":"front-end","link":"/categories/front-end/"}]}