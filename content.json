{"pages":[],"posts":[{"title":"CSS - CSS Reset vs CSS Normalize","text":"CSS Reset因近年來各家瀏覽器陸續出現，更有新舊版本的差異，所以會產生不同的預設樣式，如默認行高，邊距和各元素字體大小等方面的不一致，一個統一的預設樣式開始變得越來越重要。 最簡單粗暴的做法就是直接把所有的預設樣式強制歸 0，比如： 123456* { margin: 0; padding: 0; border: 0; font-size: 100%;}但是通用符號會匹配所有的標籤，如果開發的是大型網站，會大大加重網頁渲染時間，所以最好還是只對需要的標籤做修改。 CSS-Tricks 調查最多人使用的 Eric Meyer 的版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, font, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td { margin: 0; padding: 0; border: 0; outline: 0; font-weight: inherit; font-style: inherit; font-size: 100%; font-family: inherit; vertical-align: baseline;}/* remember to define focus styles! */:focus { outline: 0;}body { line-height: 1; color: black; background: white;}ol, ul { list-style: none;}/* tables still need &apos;cellspacing=&quot;0&quot;&apos; in the markup */table { border-collapse: separate; border-spacing: 0;}caption, th, td { text-align: left; font-weight: normal;}blockquote:before, blockquote:after,q:before, q:after { content: &quot;&quot;;}blockquote, q { quotes: &quot;&quot; &quot;&quot;;}https://meyerweb.com/eric/tools/css/reset/ CSS Normalize因為 reset.css 重置了各個瀏覽器的樣式設定，使得有些有用、常用標籤的默認樣式必須要重新設定，因為這個問題，導致了 Normalize.css 的出現。 Normalize 最大的特色就是保留原本預設 HTML 標籤的樣式，僅針對不同瀏覽器與各版本間不相容的標籤進行些微調整。 Normalize.css 的目標： 保留有用的瀏覽器默認設置，而不是將其刪除。為廣泛的 HTML 元素提供一般化的樣式。修正瀏覽器的 Bug 與不一致。透過微妙的改善提高可用性。有詳細的文檔來解釋代碼。(每個樣式都有註解是處理什麼問題。) http://nicolasgallagher.com/about-normalize-css/","link":"/2020/04/23/CSS-CSS-Reset-vs-CSS-normalize/"},{"title":"Front-end - 前端中的 MVVM 與 Vue.js","text":"MVVM（Model–view–viewmodel）是一種軟體架構模式，其核心是提供對 View 和 View Model 的雙向數據綁定，這使得 View Model 的狀態改變可以自動傳遞給 View，這就是所謂的數據雙向綁定。 MVVM？ 為什麼需要使用它？討論 MVVM 前，先稍微暸解 MVC 架構 Model 就是數據View 把數據以某種方式呈現給用戶Controller 接收並處理來自用戶的請求，並將 Model 返回給用戶 在 HTML5 出現前，MVC 做為 Web 應用的最佳實踐是沒問題的，這是因為 Web 應用的 View 層相對來說比較簡單，前端所需要的數據在後端基本上都可以處理好，View 層主要是做一下展示，那時候提倡的是 Controller 來處理複雜的業務邏輯，所以 View 層相對來說比較輕量。 在 HTML5 出現後，View 層所做的事，就不僅僅是簡單的數據展示了，要管理數據，管理用戶操作的各種狀態，還要處理移動設備上用戶各種操作行為等等。因此，前端自己也需要一個類似於 MVC 的框架來管理這些複雜的邏輯，使開發更加高效。 此時的 MVC 架構在前端開發中變成以下： Model 管理數據View UI 布局，展示數據Controller 響應用戶操作，並將 Model 更新到 View 上 這種 MVC 架構模式對於基礎的應用來看起是OK的，更是符合軟體架構的分層思想。 但實際上，隨著 H5 的不斷發展，人們更希望使用 H5 開發的應用能和 Native 媲美，或者接近於原生 App 體驗效果，於是前端應用的複雜程度已不同往日，今非昔比。這時前端就暴露了三個重要的痛點問題： 開發者在代碼中大量調用相同的 DOM API, 處理繁瑣 ，操作冗餘，使得代碼難以維護。 大量的 DOM 操作使頁面渲染性能降低，加載速度變慢，影響用戶體驗。 當 Model 頻繁發生變化，開發者需要主動更新到 View；當用戶的操作導致 Model 發生變化，開發者同樣需要將變化的數據同步到 Model 中， 這樣的工作不僅繁瑣，而且很難維護複雜多變的數據狀態。 MVVM 的出現，完美的解決了以上三個問題MVVM 由 Model,View,ViewModel 三部分組成，Model 層代表數據模型，也可以在 Model 中定義數據修改和操作的業務邏輯；View 代表 UI 組件，它負責將數據模型轉化成 UI 展現出來，ViewModel 是一個同步 View 和 Model的對象。 在MVVM架構下，View 和 Model 之間並沒有直接的聯繫，而是通過 ViewModel 進行交互，Model 和 ViewModel 之間的交互是雙向的， 因此View 數據的變化會同步到 Model 中，而 Model 數據的變化也會立即反應到 View 上。 ViewModel 通過雙向數據綁定把 View 層和 Model 層連接了起來，而 View 和 Model 之間的同步工作完全是自動的，無需人為干涉，因此開發者只需關注業務邏輯，不需要手動操作 DOM,不需要關注數據狀態的同步問題，複雜的數據狀態維護完全由 MVVM 來統一管理。 Vue.js 的細節Vue.js 可以說是前端框架中 MVVM 架構的最佳實踐，專注於 MVVM 中的 ViewModel，不僅做到了數據雙向綁定，而且也是一款相對來比較輕量級的 JS 庫，API 簡潔，很容易上手。 下面簡單了解一下 Vue.js 關於雙向綁定的一些實現細節： Vue.js 採用的是 Object.defineProperty 的 getter 和 setter，並結合觀察者模式來實現數據綁定的。當把一個普通 Javascript 對象傳給 Vue 實例來作為它的 data 選項時，Vue 將遍歷它的屬性，用 Object.defineProperty 將它們轉為 getter/setter。用戶看不到 getter/setters，但是在內部它們讓 Vue 追蹤依賴，在屬性被訪問和修改時通知變化。 Observer 數據監聽器，能夠對數據對象的所有屬性進行監聽，如有變動可拿到最新值並通知訂閱者，內部採用Object.defineProperty的getter和setter來實現Compile 指令解析器，它的作用對每個元素節點的指令進行掃描和解析，根據指令模板替換數據，以及綁定相應的更新函數Watcher 訂閱者， 作為連接 Observer 和 Compile 的橋樑，能夠訂閱並收到每個屬性變動的通知，執行指令綁定的相應回調函數Dep 消息訂閱器，內部維護了一個數組，用來收集訂閱者（Watcher），數據變動觸發notify 函數，再調用訂閱者的 update 方法 當執行 new Vue 時，Vue 就進入了初始化階段，一方面 Vue 會遍歷 data 選項中的屬性，並用 Object.defineProperty 將它們轉為 getter/setter，實現數據變化監聽功能；另一方面，Vue 的指令編譯器 Compile 對元素節點的指令進行掃描和解析，初始化視圖，並訂閱 Watcher 來更新視圖， 此時 Watcher 會將自己添加到消息訂閱器中(dep),初始化完畢。 當數據發生變化時，Observer 中的 setter方 法被觸發，setter 會立即調用 Dep.notify，Dep 開始遍歷所有的訂閱者，並調用訂閱者的 update 方法，訂閱者收到通知後對視圖進行相應的更新，完成一次數據綁定。 原文網址：https://www.cnblogs.com/onepixel/p/6034307.html","link":"/2020/04/23/Vue.js%20-%20MVVM/"},{"title":"CSS-BEM and 7-1 pattern","text":"BEM在網頁前端開發時，有時候我們會遇到一些 class 命名的問題，舉幾個例子： 比如頁面上有兩個頭像 avator，一個在 navbar 上，另外一個在文章標題旁邊，功能都是秀出頭像，只是樣式上的不同，class 就沒辦法都取為 avator。 撰寫 style 時，有時候需要來回對照現在寫的 \bclass 是在哪一個父元素下面，沒辦法看到 class 就知道他在網頁的哪個部分。 使用 Sass 時，有一個很棒的地方，就是它的巢狀結構，有沒有辦法讓他更簡潔，又一目瞭然。 有沒有一個 class 命名標準，可以一次解決上述的問題，有，那就是 BEM 了。 BEM 用元件化的觀念將整個頁面切分成不同區塊，更使得代碼擁有很好的重用性，主要分成 3 個等級： Block 區塊 Element 元素 Modifier 修飾 上面這個例子，可以很清楚的看到 class 開頭 recipe 就是他的 Block 元件本身，雙底線 _ _ 後面接這個 block 裡的元素，圖片框，詳細內容……，兩個連號 - - 後面接的是修飾，就是功能差不多，只有一點樣式不一樣，需要使用到不同的 class 時，我們會在 - - 後面加上他的描述，例如綠色按鈕 btn - - green。 BEM 命名規則 在 Sass 裡面，變得一目瞭然： 7-1 pattern 為了 Sass 的開發與維護更容易，把\b style 資料夾分成7種: base/ components/ layout/ pages/ themes/ abstracts/ vendors/ 7-1 pattern 很好的把 不同種類的 style 區分出來，避免了開發時單個 style 檔案過多行，找一個 selector 找老半天的窘境，也把一些共用的變數與接口放在專屬的 sass 檔，更輕鬆的管理整個專案的樣式。","link":"/2020/04/28/CSS-BEM-and-7-1pattern/"},{"title":"Sass - @extend 與 @Mixin 的差異","text":"什麼時候該用 @mixin ?@mixin 主要有兩個用途： 幫你把會重複用到的樣式統一做一個接口，方便後續維護。 還有可以帶入變數的特性，讓具重複性的代碼，可以更彈性的使用。 但是他並不是沒有成本，當你在高度重複的代碼裡使用 @mixin，在編譯過後，會發現其實他並沒有變得更精簡，他只是方便我們開發而已。 1234567891011121314151617181920212223242526272829303132333435363738@mixin title{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.sidebar h2{ @include title;}.content h4{ @include title;}.main h3{ @include title;}//編譯出來的CSS.sidebar h2{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.content h4{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.main h3{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;} 那有什麼方法可以既方便維護又不會編譯出來一大串重複的程式碼呢？這時候就輪到 @extend 出場了。 @extend@extend 主要是把重複樣式的 selector 集合在一起，就可以達到既方便維護又節省程式碼的效果： 12345678910111213141516171819202122232425// %title是css會被堆疊的位置%title{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.sidebar h2{ @extend %title}.content h4{ @extend %title}.main h3{ @extend %title}//編譯出來的CSS.sidebar h2,.content h4,.main h3{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}","link":"/2020/04/29/Sass-extend%20vs%20Mixin/"},{"title":"Coding Problems - Google 工程師 Coding 面試範例","text":"How to: Work at Google — Example Coding/Engineering InterviewLINK： https://www.youtube.com/watch?v=XKu_SEDAykw 從影片中學到什麼這個影片主要介紹 Google 在 coding interview 環節的模擬情況，最大的重點在於如何解題，可以用什麼樣的流程清楚展現自己如何解決問題，除了題目結果外，最重要的是解題過程中如何思考，整個流程可以細分成： 面試官闡述問題，在上面（i.e. sorted array）寫下 key points，確保所有細節，展示組織能力 在次確認 inputs outputs 思考問題重點是什麼，有時間空間內存的限制嗎 用最簡單/暴力解法開始解題，口頭描述，表明出你善於思考與批判 說明這個解法不是最佳解，它的 bigO，readable 說明 code 有什麼地方是多餘的，重複的，可以怎麼去解決 在真正開始寫下代碼前，先在問題上寫下我要怎麼做 開始將代碼模塊化，把代碼分成小片段，需要時寫下註解 真正寫下解法，前面準備得越多，能寫下的代碼就越好，千萬不要不確定怎麼寫就開始 思考程式什麼情況下會出錯，假設有人想要破壞你的程式碼，什麼樣的 inputs 會導致程式出錯，告訴面試官我會怎麼測試這段程式碼 命名盡量用人看得懂的 告訴面試官你會怎麼加強你的代碼，有沒有辦法更 readable，會怎麼使用 google 來幫助你 在這個範例題目我用 JavaScript 實作一次Question：輸入數列，裡面的數字兩兩相加，等於8的話回傳 true[1,2,3,9] if sum = 8 return false[1,2,4,4] if sum = 8 return true 釐清問題後首先以暴力解法 run 一遍，完全遍歷整個陣列 12345678910111213const arr1 = [1, 2, 3, 9];const arr2 = [1, 2, 4, 4];function checkSumEqual(arr) { for(let i = 0; i &lt; arr.length - 1; i++){ for(let j = 0; j &lt; arr.length - 1; j++){ if(arr[i] + arr[j] == 8) return true } } return false};console.log(checkSumEqual(arr2)); 可以發現這種解法的時間複雜度是 Ｏ(n^2)，而且會有重複相加的情形，開始思考有什麼方式可以不會重複相加，可能會想到使用類似 Selection Sort 把第二層迴圈 j 初始值從 0 改為 i，解決了重複相加的問題，相比原本來說好了一點，但是還是一樣使用了兩層的迴圈，時間複雜度一樣是 Ｏ(n^2)，所以在思考看看有沒有其他方法。在影片裡被面試者想到的是縮小範圍的方式，最大值加最小值，如果大於 8，最大值 index - 1，反之如果小於 8 就讓最小值 index + 1，如果中間遇到相加等於 8 就直接回傳 true，迴圈到最小值 &gt; 最大值為止 1234567891011121314151617181920const arr1 = [1, 2, 3, 9];const arr2 = [1, 2, 4, 4];function checkSumEqual(arr) { let min = 0; let max = arr.length - 1; while(min &lt; max){ let s = arr[min] + arr[max]; if(s == 8){ return true }else if(s &gt; 8){ max--; }else{ min++; } } return false};console.log(checkSumEqual(arr2)); 看似完美的解決問題，只有使用到一個迴圈，時間複雜度 Ｏ(n)，但是在這裡面試官丟出一個難題，不保證輸入的值有經過排序，所以這個解法行不通了，如果還要做排序那可能效能還沒有暴力解好，所以還要再看看有什麼方式，可能會想到 hash table 的方式，做一次遍歷，把 8 減掉現在遍歷到的數字放到 hash 表中，如果現在遍歷到的數字匹配到 hash 的數字，就代表有一對數字相加為 8，回傳 true 12345678910111213const arr1 = [1, 2, 3, 9];const arr2 = [1, 2, 4, 4];function checkSumEqual(arr) { let hashTable = new Set(); for(i = 0; i &lt; arr.length; i++){ if(hashTable.has(arr[i])) return true hashTable.add(8 - arr[i]) } return false}console.log(checkSumEqual(arr2)); 這樣解決了遍歷一次，時間複雜度O(n)，而且不會有排序問題，因為 HashTable 是慢慢把前面遍歷的值處理後加進去，也不會有自己加自己的狀況產生，很好的解法。 最後到這裡就告一段落了，可能還會再問一些相關問題，比如輸入的數字太多，無法負荷，你會用什麼方法解決，這邊就是把自己的想法講出來就好了，可能是把輸入分段處理，分段處理又會遇到什麼問題……","link":"/2020/05/15/coding-problems-google-coding-interview-example/"},{"title":"JavaScript Value vs. Reference","text":"在 JavaScript 環境中，如果你輸入：12console.log( [] == [] );console.log( {} == {} ); 兩個 log 得到的會是 true 還是 false ?答案都是： false 再來看看其他例子123456var object1 = {value: 10};var object2 = object1;var object3 = {value: 10};console.log(object1 == object2); // trueconsole.log(object1 == object3); // false 為什麼 object1 跟 object3 裡面的值一樣，卻不相等？JavaScript 的 物件 與 一般變數 在存取時，是有不同的機制的，一般變數不論是 字串、Number、Boolean、Null…，變數在賦值時，指向的是它的 Value，Value 相等比較出來結果也會相等，而 Object 就不同了，在宣告一個變數是 Object 或 Array 時，等於是創建了一個獨一無二的空間，拿兩個不同的空間比較，結果當然也就是 false 結論所以在 JavaScript 中，比較兩者是否相同前，也要注意比較的兩方是 by Value 還是 by Reference","link":"/2020/05/18/javascript-value-vs-refrerence/"},{"title":"Data Structure - Array","text":"","link":"/2020/06/06/DataStructure/data-structure-javascript-array/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Sass","slug":"Sass","link":"/tags/Sass/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"DataStructure","slug":"DataStructure","link":"/tags/DataStructure/"}],"categories":[{"name":"front-end","slug":"front-end","link":"/categories/front-end/"},{"name":"DataStructure","slug":"DataStructure","link":"/categories/DataStructure/"},{"name":"CodingProblems","slug":"CodingProblems","link":"/categories/CodingProblems/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}