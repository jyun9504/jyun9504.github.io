{"pages":[],"posts":[{"title":"CSS - CSS Reset vs CSS Normalize","text":"CSS Reset因近年來各家瀏覽器陸續出現，更有新舊版本的差異，所以會產生不同的預設樣式，如默認行高，邊距和各元素字體大小等方面的不一致，一個統一的預設樣式開始變得越來越重要。 最簡單粗暴的做法就是直接把所有的預設樣式強制歸 0，比如： 123456* { margin: 0; padding: 0; border: 0; font-size: 100%;}但是通用符號會匹配所有的標籤，如果開發的是大型網站，會大大加重網頁渲染時間，所以最好還是只對需要的標籤做修改。 CSS-Tricks 調查最多人使用的 Eric Meyer 的版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, font, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td { margin: 0; padding: 0; border: 0; outline: 0; font-weight: inherit; font-style: inherit; font-size: 100%; font-family: inherit; vertical-align: baseline;}/* remember to define focus styles! */:focus { outline: 0;}body { line-height: 1; color: black; background: white;}ol, ul { list-style: none;}/* tables still need &apos;cellspacing=&quot;0&quot;&apos; in the markup */table { border-collapse: separate; border-spacing: 0;}caption, th, td { text-align: left; font-weight: normal;}blockquote:before, blockquote:after,q:before, q:after { content: &quot;&quot;;}blockquote, q { quotes: &quot;&quot; &quot;&quot;;}https://meyerweb.com/eric/tools/css/reset/ CSS Normalize因為 reset.css 重置了各個瀏覽器的樣式設定，使得有些有用、常用標籤的默認樣式必須要重新設定，因為這個問題，導致了 Normalize.css 的出現。 Normalize 最大的特色就是保留原本預設 HTML 標籤的樣式，僅針對不同瀏覽器與各版本間不相容的標籤進行些微調整。 Normalize.css 的目標： 保留有用的瀏覽器默認設置，而不是將其刪除。為廣泛的 HTML 元素提供一般化的樣式。修正瀏覽器的 Bug 與不一致。透過微妙的改善提高可用性。有詳細的文檔來解釋代碼。(每個樣式都有註解是處理什麼問題。) http://nicolasgallagher.com/about-normalize-css/","link":"/2020/04/23/CSS-CSS-Reset-vs-CSS-normalize/"},{"title":"Front-end - 前端中的 MVVM 與 Vue.js","text":"MVVM（Model–view–viewmodel）是一種軟體架構模式，其核心是提供對 View 和 View Model 的雙向數據綁定，這使得 View Model 的狀態改變可以自動傳遞給 View，這就是所謂的數據雙向綁定。 MVVM？ 為什麼需要使用它？討論 MVVM 前，先稍微暸解 MVC 架構 Model 就是數據View 把數據以某種方式呈現給用戶Controller 接收並處理來自用戶的請求，並將 Model 返回給用戶 在 HTML5 出現前，MVC 做為 Web 應用的最佳實踐是沒問題的，這是因為 Web 應用的 View 層相對來說比較簡單，前端所需要的數據在後端基本上都可以處理好，View 層主要是做一下展示，那時候提倡的是 Controller 來處理複雜的業務邏輯，所以 View 層相對來說比較輕量。 在 HTML5 出現後，View 層所做的事，就不僅僅是簡單的數據展示了，要管理數據，管理用戶操作的各種狀態，還要處理移動設備上用戶各種操作行為等等。因此，前端自己也需要一個類似於 MVC 的框架來管理這些複雜的邏輯，使開發更加高效。 此時的 MVC 架構在前端開發中變成以下： Model 管理數據View UI 布局，展示數據Controller 響應用戶操作，並將 Model 更新到 View 上 這種 MVC 架構模式對於基礎的應用來看起是OK的，更是符合軟體架構的分層思想。 但實際上，隨著 H5 的不斷發展，人們更希望使用 H5 開發的應用能和 Native 媲美，或者接近於原生 App 體驗效果，於是前端應用的複雜程度已不同往日，今非昔比。這時前端就暴露了三個重要的痛點問題： 開發者在代碼中大量調用相同的 DOM API, 處理繁瑣 ，操作冗餘，使得代碼難以維護。 大量的 DOM 操作使頁面渲染性能降低，加載速度變慢，影響用戶體驗。 當 Model 頻繁發生變化，開發者需要主動更新到 View；當用戶的操作導致 Model 發生變化，開發者同樣需要將變化的數據同步到 Model 中， 這樣的工作不僅繁瑣，而且很難維護複雜多變的數據狀態。 MVVM 的出現，完美的解決了以上三個問題MVVM 由 Model,View,ViewModel 三部分組成，Model 層代表數據模型，也可以在 Model 中定義數據修改和操作的業務邏輯；View 代表 UI 組件，它負責將數據模型轉化成 UI 展現出來，ViewModel 是一個同步 View 和 Model的對象。 在MVVM架構下，View 和 Model 之間並沒有直接的聯繫，而是通過 ViewModel 進行交互，Model 和 ViewModel 之間的交互是雙向的， 因此View 數據的變化會同步到 Model 中，而 Model 數據的變化也會立即反應到 View 上。 ViewModel 通過雙向數據綁定把 View 層和 Model 層連接了起來，而 View 和 Model 之間的同步工作完全是自動的，無需人為干涉，因此開發者只需關注業務邏輯，不需要手動操作 DOM,不需要關注數據狀態的同步問題，複雜的數據狀態維護完全由 MVVM 來統一管理。 Vue.js 的細節Vue.js 可以說是前端框架中 MVVM 架構的最佳實踐，專注於 MVVM 中的 ViewModel，不僅做到了數據雙向綁定，而且也是一款相對來比較輕量級的 JS 庫，API 簡潔，很容易上手。 下面簡單了解一下 Vue.js 關於雙向綁定的一些實現細節： Vue.js 採用的是 Object.defineProperty 的 getter 和 setter，並結合觀察者模式來實現數據綁定的。當把一個普通 Javascript 對象傳給 Vue 實例來作為它的 data 選項時，Vue 將遍歷它的屬性，用 Object.defineProperty 將它們轉為 getter/setter。用戶看不到 getter/setters，但是在內部它們讓 Vue 追蹤依賴，在屬性被訪問和修改時通知變化。 Observer 數據監聽器，能夠對數據對象的所有屬性進行監聽，如有變動可拿到最新值並通知訂閱者，內部採用Object.defineProperty的getter和setter來實現Compile 指令解析器，它的作用對每個元素節點的指令進行掃描和解析，根據指令模板替換數據，以及綁定相應的更新函數Watcher 訂閱者， 作為連接 Observer 和 Compile 的橋樑，能夠訂閱並收到每個屬性變動的通知，執行指令綁定的相應回調函數Dep 消息訂閱器，內部維護了一個數組，用來收集訂閱者（Watcher），數據變動觸發notify 函數，再調用訂閱者的 update 方法 當執行 new Vue 時，Vue 就進入了初始化階段，一方面 Vue 會遍歷 data 選項中的屬性，並用 Object.defineProperty 將它們轉為 getter/setter，實現數據變化監聽功能；另一方面，Vue 的指令編譯器 Compile 對元素節點的指令進行掃描和解析，初始化視圖，並訂閱 Watcher 來更新視圖， 此時 Watcher 會將自己添加到消息訂閱器中(dep),初始化完畢。 當數據發生變化時，Observer 中的 setter方 法被觸發，setter 會立即調用 Dep.notify，Dep 開始遍歷所有的訂閱者，並調用訂閱者的 update 方法，訂閱者收到通知後對視圖進行相應的更新，完成一次數據綁定。 原文網址：https://www.cnblogs.com/onepixel/p/6034307.html","link":"/2020/04/23/Vue.js%20-%20MVVM/"},{"title":"CSS - BEM and 7-1 pattern","text":"BEM在網頁前端開發時，有時候我們會遇到一些 class 命名的問題，舉幾個例子： 比如頁面上有兩個頭像 avator，一個在 navbar 上，另外一個在文章標題旁邊，功能都是秀出頭像，只是樣式上的不同，class 就沒辦法都取為 avator。 撰寫 style 時，有時候需要來回對照現在寫的 \bclass 是在哪一個父元素下面，沒辦法看到 class 就知道他在網頁的哪個部分。 使用 Sass 時，有一個很棒的地方，就是它的巢狀結構，有沒有辦法讓他更簡潔，又一目瞭然。 有沒有一個 class 命名標準，可以一次解決上述的問題，有，那就是 BEM 了。 BEM 用元件化的觀念將整個頁面切分成不同區塊，更使得代碼擁有很好的重用性，主要分成 3 個等級： Block 區塊 Element 元素 Modifier 修飾 上面這個例子，可以很清楚的看到 class 開頭 recipe 就是他的 Block 元件本身，雙底線 _ _ 後面接這個 block 裡的元素，圖片框，詳細內容……，兩個連號 - - 後面接的是修飾，就是功能差不多，只有一點樣式不一樣，需要使用到不同的 class 時，我們會在 - - 後面加上他的描述，例如綠色按鈕 btn - - green。 BEM 命名規則 在 Sass 裡面，變得一目瞭然： 7-1 pattern 為了 Sass 的開發與維護更容易，把\b style 資料夾分成7種: base/ components/ layout/ pages/ themes/ abstracts/ vendors/ 7-1 pattern 很好的把 不同種類的 style 區分出來，避免了開發時單個 style 檔案過多行，找一個 selector 找老半天的窘境，也把一些共用的變數與接口放在專屬的 sass 檔，更輕鬆的管理整個專案的樣式。","link":"/2020/04/28/CSS-BEM-and-7-1pattern/"},{"title":"Sass - @extend 與 @Mixin 的差異","text":"什麼時候該用 @mixin ?@mixin 主要有兩個用途： 幫你把會重複用到的樣式統一做一個接口，方便後續維護。 還有可以帶入變數的特性，讓具重複性的代碼，可以更彈性的使用。 但是他並不是沒有成本，當你在高度重複的代碼裡使用 @mixin，在編譯過後，會發現其實他並沒有變得更精簡，他只是方便我們開發而已。 1234567891011121314151617181920212223242526272829303132333435363738@mixin title{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.sidebar h2{ @include title;}.content h4{ @include title;}.main h3{ @include title;}//編譯出來的CSS.sidebar h2{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.content h4{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.main h3{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;} 那有什麼方法可以既方便維護又不會編譯出來一大串重複的程式碼呢？這時候就輪到 @extend 出場了。 @extend@extend 主要是把重複樣式的 selector 集合在一起，就可以達到既方便維護又節省程式碼的效果： 12345678910111213141516171819202122232425// %title是css會被堆疊的位置%title{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.sidebar h2{ @extend %title}.content h4{ @extend %title}.main h3{ @extend %title}//編譯出來的CSS.sidebar h2,.content h4,.main h3{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}","link":"/2020/04/29/Sass-extend%20vs%20Mixin/"},{"title":"Coding Problems - Google 工程師 Coding 面試範例","text":"How to: Work at Google — Example Coding/Engineering InterviewLINK： https://www.youtube.com/watch?v=XKu_SEDAykw 從影片中學到什麼這個影片主要介紹 Google 在 coding interview 環節的模擬情況，最大的重點在於如何解題，可以用什麼樣的流程清楚展現自己如何解決問題，除了題目結果外，最重要的是解題過程中如何思考，整個流程可以細分成： 面試官闡述問題，在上面（i.e. sorted array）寫下 key points，確保所有細節，展示組織能力 在次確認 inputs outputs 思考問題重點是什麼，有時間空間內存的限制嗎 用最簡單/暴力解法開始解題，口頭描述，表明出你善於思考與批判 說明這個解法不是最佳解，它的 bigO，readable 說明 code 有什麼地方是多餘的，重複的，可以怎麼去解決 在真正開始寫下代碼前，先在問題上寫下我要怎麼做 開始將代碼模塊化，把代碼分成小片段，需要時寫下註解 真正寫下解法，前面準備得越多，能寫下的代碼就越好，千萬不要不確定怎麼寫就開始 思考程式什麼情況下會出錯，假設有人想要破壞你的程式碼，什麼樣的 inputs 會導致程式出錯，告訴面試官我會怎麼測試這段程式碼 命名盡量用人看得懂的 告訴面試官你會怎麼加強你的代碼，有沒有辦法更 readable，會怎麼使用 google 來幫助你 在這個範例題目我用 JavaScript 實作一次Question：輸入數列，裡面的數字兩兩相加，等於8的話回傳 true[1,2,3,9] if sum = 8 return false[1,2,4,4] if sum = 8 return true 釐清問題後首先以暴力解法 run 一遍，完全遍歷整個陣列 12345678910111213const arr1 = [1, 2, 3, 9];const arr2 = [1, 2, 4, 4];function checkSumEqual(arr) { for(let i = 0; i &lt; arr.length - 1; i++){ for(let j = 0; j &lt; arr.length - 1; j++){ if(arr[i] + arr[j] == 8) return true } } return false};console.log(checkSumEqual(arr2)); 可以發現這種解法的時間複雜度是 Ｏ(n^2)，而且會有重複相加的情形，開始思考有什麼方式可以不會重複相加，可能會想到使用類似 Selection Sort 把第二層迴圈 j 初始值從 0 改為 i，解決了重複相加的問題，相比原本來說好了一點，但是還是一樣使用了兩層的迴圈，時間複雜度一樣是 Ｏ(n^2)，所以在思考看看有沒有其他方法。在影片裡被面試者想到的是縮小範圍的方式，最大值加最小值，如果大於 8，最大值 index - 1，反之如果小於 8 就讓最小值 index + 1，如果中間遇到相加等於 8 就直接回傳 true，迴圈到最小值 &gt; 最大值為止 1234567891011121314151617181920const arr1 = [1, 2, 3, 9];const arr2 = [1, 2, 4, 4];function checkSumEqual(arr) { let min = 0; let max = arr.length - 1; while(min &lt; max){ let s = arr[min] + arr[max]; if(s == 8){ return true }else if(s &gt; 8){ max--; }else{ min++; } } return false};console.log(checkSumEqual(arr2)); 看似完美的解決問題，只有使用到一個迴圈，時間複雜度 Ｏ(n)，但是在這裡面試官丟出一個難題，不保證輸入的值有經過排序，所以這個解法行不通了，如果還要做排序那可能效能還沒有暴力解好，所以還要再看看有什麼方式，可能會想到 hash table 的方式，做一次遍歷，把 8 減掉現在遍歷到的數字放到 hash 表中，如果現在遍歷到的數字匹配到 hash 的數字，就代表有一對數字相加為 8，回傳 true 12345678910111213const arr1 = [1, 2, 3, 9];const arr2 = [1, 2, 4, 4];function checkSumEqual(arr) { let hashTable = new Set(); for(i = 0; i &lt; arr.length; i++){ if(hashTable.has(arr[i])) return true hashTable.add(8 - arr[i]) } return false}console.log(checkSumEqual(arr2)); 這樣解決了遍歷一次，時間複雜度O(n)，而且不會有排序問題，因為 HashTable 是慢慢把前面遍歷的值處理後加進去，也不會有自己加自己的狀況產生，很好的解法。 最後到這裡就告一段落了，可能還會再問一些相關問題，比如輸入的數字太多，無法負荷，你會用什麼方法解決，這邊就是把自己的想法講出來就好了，可能是把輸入分段處理，分段處理又會遇到什麼問題……","link":"/2020/05/15/coding-problems-google-coding-interview-example/"},{"title":"JavaScript - Value vs. Reference","text":"在 JavaScript 環境中，如果你輸入：12console.log( [] == [] );console.log( {} == {} ); 兩個 log 得到的會是 true 還是 false ?答案都是： false 再來看看其他例子123456var object1 = {value: 10};var object2 = object1;var object3 = {value: 10};console.log(object1 == object2); // trueconsole.log(object1 == object3); // false 為什麼 object1 跟 object3 裡面的值一樣，卻不相等？JavaScript 的 物件 與 一般變數 在存取時，是有不同的機制的，一般變數不論是 字串、Number、Boolean、Null…，變數在賦值時，指向的是它的 Value，Value 相等比較出來結果也會相等，而 Object 就不同了，在宣告一個變數是 Object 或 Array 時，等於是創建了一個獨一無二的空間，拿兩個不同的空間比較，結果當然也就是 false 結論所以在 JavaScript 中，比較兩者是否相同前，也要注意比較的兩方是 by Value 還是 by Reference","link":"/2020/05/18/javascript-value-vs-refrerence/"},{"title":"Data Structure - Array","text":"Array 陣列Array 是最簡單也最被廣泛使用的資料結構，幾乎所有程式語言都具備陣列這個資料結構，以定義來說，他是由相同類型的元素（element）的集合所組成的資料結構，在一般程式語言中陣列只能儲存同樣型別的值，但在 JavaScript 則可以儲存不同型別的值（也應該盡量避免）。 優點：lookup： 只需要利用 index 即可對特定位置的資料作存取與查詢，此動作之時間複雜度為 O(1)push： 資料到最尾端時也只要時間複雜度 O(1) 缺點：insert、 delete： Array 的元素在記憶體中是連續儲存的，所以假設要新增或刪除 Array 的第1個位置的元素，則須將第2~last 位置的元素一一往前或往後搬動，時間複雜度為 O(n) 使用時機 : 希望能夠快速存取查詢資料，時間複雜度只有 O(1)。 已知欲處理的資料數量，便能確認 Array 的大小。#在 JavaScript 中的 Array 是 Dynamic Array，動態分配陣列大小可能會導致搬移 O(n) 要求記憶體空間的使用越少越好。 Javascript 陣列：建立 class123456class MyArray { constructor() { this.length = 0; this.data = {}; }} get123456class MyArray { //...以上省略 get(index) { return data[index]; }} push12345678class MyArray { //...以上省略 push(item) { this.data[this.length] = item; this.length++; return this.length; }} pop123456789class MyArray { //...以上省略 pop() { const lastItem = this.data[length - 1]; delete this.data[this.length - 1]; this.length--; return lastItem; }} delete12345678class MyArray { //...以上省略 delete(index) { const item = this.data[index]; this.shiftItems(index); return item; }} shift12345678910class MyArray { //...以上省略 shiftItems(index) { for(let i = index; i &lt; this.length - 1; i++){ this.data[i] = this.data[i+1]; } delete this.data[this.length - 1]; this.length--; }} 陣列在 JavaScript 上內建的方法新增陣列 使用 new Array()，可以自定陣列大小123let newArr1 = new Array();let newArr2 = new Array(999);let students = new Array(&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;); 使用 [] 宣告陣列12let newArr1 = [];let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;]; push 、 pop 、 unshift 、 shift 使用 push、pop 新增或移除最後陣列元素：1234567let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;];// 將 巨石強森 加入最後元素 students.push(&apos;巨石強森&apos;); // [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;, &apos;巨石強森&apos;]// 將剛剛加入的 巨石強森 移除students.pop(); // [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;] 將元素插入陣列首位 和 移除首位的元素 unshift、shift ：1234567let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;];// 將 巨石強森 插入首位students.unshift(&apos;巨石強森&apos;); // [&apos;巨石強森&apos;, &apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;]// 將剛剛加入的 巨石強森 移除students.shift(); // [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;] 二維陣列在 JavaScript 中只其實只支援一維陣列，但是可以用陣列嵌套陣列的方式來模擬多維陣列：12345678910let students = [];students[0] = [&apos;巨石強森&apos;, &apos;阿諾史瓦辛格&apos;];students[1] = [&apos;席維斯史特龍&apos;, &apos;馮迪索&apos;];// students = [[&apos;巨石強森&apos;, &apos;阿諾史瓦辛格&apos;], [&apos;席維斯史特龍&apos;, &apos;馮迪索&apos;]]for(let i = 0; i &lt; students.length; i++) { for(let j = 0; j &lt; students[i].length; j++) { console.log(students[i][j]); // 巨石強森 阿諾史瓦辛格 席維斯史特龍 馮迪索 }} 常用陣列方法陣列迭代 forEach，單純對陣列每個元素都進行迭代123numbers.forEach(function(value, index){ console.log(value, index);}); map，對陣列每個元素都進行迭代並回傳新的陣列，不會改變原本陣列。1234567let numbers = [1, 2, 3, 4];let newNumbers = numbers.map(function(value, index) { return value + 1});console.log(numbers); // [1, 2, 3, 4]console.log(newNumbers); // [2, 3, 4, 5] every，對陣列每個元素都進行迭代，若迭代函數內容皆為 true，則回傳 true，反之回傳 false1234567let ages = [32, 33, 16, 40];function checkAdult(age) { return (age &gt;= 18) ? true : false;}console.log(ages.every(checkAdult)); // false some，若迭代函數中有一個為 true 即回傳 true，反之回傳 false1234567let ages = [3, 10, 18, 20];function checkAdult(age) { return (age &gt;= 18) ? true : false;}console.log(ages.some(checkAdult)); // true reduce，由左向右累加\b，參數有四個 previousValue,currentValue, index, array123456let numbers = [2, 3, 5, 6];function getSum(total, num) { return total + num;}console.log(numbers.reduce(getSum)); // 16 reduceRight，由右向左累加\b123456let numbers = [2, 3, 5, 6];function getSum(total, num) { return total + num;}console.log(numbers.reduce(getSum)); // 16 filter，依據條件回傳過濾後的陣列1234567let ages = [32, 33, 16, 40];function checkAdult(age) { return age &gt;= 18;}console.log(ages.filter(checkAdult)); // [32, 33, 40] 搜尋 indexOf，搜尋第一個匹配到的元素的 index12let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;, &apos;巨石強森&apos;];let a = students.indexOf(&apos;馮迪索&apos;); // 2 lastIndexOf，搜尋最後一個匹配到的元素的 index12let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;, &apos;巨石強森&apos;,&apos;馮迪索&apos;];let a = students.indexOf(&quot;Orange&quot;); // 4 排序 sort，將陣列內容進行排序，回傳排序後陣列，若為文字則根據 ASCII Code 編碼大小進行比較12let fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.sort(); // [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Mango&quot;, &quot;Orange&quot;] reverse，將陣列內容反轉12let fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.reverse(); // [&quot;Mango&quot;, &quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;] 陣列合併和切割 join，將陣列轉成字串，預設以分隔符號,串連成字串12345let fruits = [&apos;Banana&apos;, &apos;Orange&apos;, &apos;Lemon&apos;, &apos;Apple&apos;, &apos;Raspberry&apos;];console.log(fruits.join()); // Banana,Orange,Lemon,Apple,Raspberrylet fruits = [&apos;Banana&apos;, &apos;Orange&apos;, &apos;Lemon&apos;, &apos;Apple&apos;, &apos;Raspberry&apos;];console.log(fruits.join(&apos;&apos;)); // BananaOrangeLemonAppleRaspberry toString，回傳陣列轉成字串的結果，不會改變原本陣列，類似 join，但是只能用預設 , 做分隔12let fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.toString(); // Banana,Orange,Apple,Mango split，將字串轉成陣列12let a = &apos;1,2,3,4&apos;;console.log(a.split(&apos;,&apos;)); //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;] concat，合併陣列123let hege = [&quot;Cecilie&quot;, &quot;Leo&quot;];let stale = [&quot;Emil&quot;, &quot;May&quot;, &quot;Linus&quot;];console.log(hege.concat(stale)); // [&apos;Cecilie&apos;, &apos;Leo&apos;, &apos;Emil&apos;, &apos;May&apos;, &apos;Linus&apos;] slice，剪裁並回傳新的陣列12let fruits = [&apos;Banana&apos;, &apos;Orange&apos;, &apos;Lemon&apos;, &apos;Apple&apos;, &apos;Raspberry&apos;];console.log(fruits.slice(1, 3)); // [&apos;Orange&apos;, &apos;Lemon&apos;, &apos;Apple&apos;]","link":"/2020/06/06/DataStructure/data-structure-javascript-array/"},{"title":"Data Structure - Linked List","text":"Linked List 連結串列Linked list 是一種常見的資料結構，其使用 node (節點) 來記錄、表示、儲存資料 (data)，並利用每個 node 中的 pointer 指向下一個 node，藉此將多個 node 串連起來，形成 Linked list，並以 NULL 來代表 Linked list的終點。 優點：append、prepend： 只要對 head 或 tail 調整 pointer 所指向的 node 即可 O(1)，不需要像 array 一樣搬動其餘元素。 不需使用連續記憶體空間，不需事先指定串列大小 各節點資料型態並不一定要相同 缺點：lookup： 沒有像 Array 的 index 那樣方便，若要找到特定node，需要從頭(head node) traverse，搜尋的時間複雜度為 O(n)。 insert、remove： node，需要先作 O(n) traverse 到特定 node 後，再作後續新增、刪除 node …的動作。 需要額外的記憶體空間來儲存指到下一個 node 的 pointer。 使用時機： 無法預期資料數量時，使用 Linked List 沒有 resize 的問題。 需要頻繁地新增/刪除資料時。 不需要快速存取查詢資料時。 Javascript Linked List：建立 class123456789101112class LinkedList { constructor(value) { this.head = { value: value, next: null }; this.tail = this.head; this.length = 1; }}let myLinkedList = new LinkedList(0); append123456789101112131415161718192021222324252627class LinkedList { //...以上省略 append(value) { const newNode = { value: value, next: null } //直接將最後一個 node 指向新的 node this.tail.next = newNode; this.tail = newNode; this.length++; return this; } //照順序打印所有value printList() { const array = []; let currentNode = this.head; while(currentNode !== null){ array.push(currentNode.value) currentNode = currentNode.next } return array; }}myLinkedList.append(1);myLinkedList.printList(1); prepend1234567891011prepend(value) { const newNode = { value: value, next: null } // 將新節點 pointer 指向原本的 head，再將 head 變更為新節點 newNode.next = this.head; this.head = newNode; this.length++; return this;} insert1234567891011121314151617181920212223242526272829insert(index, value){ //檢查輸入index是否存在 if(index &gt;= this.length) { console.log(&apos;yes&apos;) return this.append(value); } const newNode = { value: value, next: null } //找到要 insert 的上一個節點，將 pointer 指向新節點，新節點的 pointer 指向原來 index 上的節點 const leader = this.traverseToIndex(index-1); const holdingPointer = leader.next; leader.next = newNode; newNode.next = holdingPointer; this.length++; return this.printList();}traverseToIndex(index) { let counter = 0; let currentNode = this.head; while(counter !== index){ currentNode = currentNode.next; counter++; } return currentNode;} remove1234567remove(index) { const leader = this.traverseToIndex(index-1); const unwantedNode = leader.next; leader.next = unwantedNode.next; this.length--; return this.printList();} indexOf123456789101112indexOf(value) { let currentNode = this.head; let index = 0; while(currentNode) { if(value === currentNode.value) { return index; } index++; currentNode = currentNode.next; } return -1;}","link":"/2020/06/06/DataStructure/data-structure-javascript-linked-list/"},{"title":"Data Structure - Hash Table","text":"Hash Table 雜湊表Hash Table，也可稱作 Hash Map，是 Dictionary 類別中雜湊表的一種實作。實作的思路是：當要把資料放到雜湊表時，先給定一個 key 和存放的 value，並將 key 的每個字元轉換成 ASCII Code 或 Unicode Code 並相加，這個相加的值即是 hash 鍵值，在 table 陣列上對應到存放的 value。 優點：insert、lookup、delete： 使用 key 鍵值可以直接透過 hash function 找到 value 所在，如果不考慮 collisions，以上的操作時間複雜度為 O(n) 缺點： 儲存不按照順序，有些按照順序的操作被限制，例如想要處理有時間順序的 data，或是希望儲存的 data 可以被排序。 Python 中例外，Python 默認將字典排序了，因此，在該語言中，Array（Python中的List）和Hash Table（Python中的Dict）之間的區別較小：https://softwaremaniacs.org/blog/2020/02/05/dicts-ordered/en/ 因為有 collisions 問題，必須分配大量內存才能有效工作。 使用時機 : 在搜尋引擎可以用來縮小搜尋範圍，例如在搜尋的時候輸入關鍵字，我們可以把這個關鍵字傳進 hash function，然後 hash function 就可以指出這個關鍵字對應到的桶子，這時候再到這個桶子裡搜尋網頁就可以了。 Javascript Hash Table：建立 class12345678910111213class HashTable { constructor(size){ this.data = new Array(size); } //簡易的雜湊 _hash(key) { let hash = 0; for (let i =0; i &lt; key.length; i++){ hash = (hash + key.charCodeAt(i) * i) % this.data.length } return hash; }} set1234567891011class HashTable { //...以上省略 set(key, value) { let address = this._hash(key); if (!this.data[address]) { this.data[address] = []; } this.data[address].push([key, value]); return this.data; }} get123456789101112131415class HashTable { //...以上省略 get(key){ const address = this._hash(key); const currentBucket = this.data[address] if (currentBucket) { for(let i = 0; i &lt; currentBucket.length; i++){ if(currentBucket[i][0] === key) { return currentBucket[i][1] } } } return undefined; }}","link":"/2020/06/07/DataStructure/data-structure-javascript-hash-table/"},{"title":"Data Structure - Stack & Queue","text":"Stack優點：缺點：使用時機 : Javascript Stack：建立 class","link":"/2020/06/10/DataStructure/data-structure-javascript-stack-and-queue/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Sass","slug":"Sass","link":"/tags/Sass/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"DataStructure","slug":"DataStructure","link":"/tags/DataStructure/"}],"categories":[{"name":"front-end","slug":"front-end","link":"/categories/front-end/"},{"name":"DataStructure","slug":"DataStructure","link":"/categories/DataStructure/"},{"name":"CodingProblems","slug":"CodingProblems","link":"/categories/CodingProblems/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}