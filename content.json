{"pages":[],"posts":[{"title":"CSS - CSS Reset vs CSS Normalize","text":"CSS Reset因近年來各家瀏覽器陸續出現，更有新舊版本的差異，所以會產生不同的預設樣式，如默認行高，邊距和各元素字體大小等方面的不一致，一個統一的預設樣式開始變得越來越重要。 最簡單粗暴的做法就是直接把所有的預設樣式強制歸 0，比如： 123456* { margin: 0; padding: 0; border: 0; font-size: 100%;}但是通用符號會匹配所有的標籤，如果開發的是大型網站，會大大加重網頁渲染時間，所以最好還是只對需要的標籤做修改。 CSS-Tricks 調查最多人使用的 Eric Meyer 的版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, font, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td { margin: 0; padding: 0; border: 0; outline: 0; font-weight: inherit; font-style: inherit; font-size: 100%; font-family: inherit; vertical-align: baseline;}/* remember to define focus styles! */:focus { outline: 0;}body { line-height: 1; color: black; background: white;}ol, ul { list-style: none;}/* tables still need &apos;cellspacing=&quot;0&quot;&apos; in the markup */table { border-collapse: separate; border-spacing: 0;}caption, th, td { text-align: left; font-weight: normal;}blockquote:before, blockquote:after,q:before, q:after { content: &quot;&quot;;}blockquote, q { quotes: &quot;&quot; &quot;&quot;;}https://meyerweb.com/eric/tools/css/reset/ CSS Normalize因為 reset.css 重置了各個瀏覽器的樣式設定，使得有些有用、常用標籤的默認樣式必須要重新設定，因為這個問題，導致了 Normalize.css 的出現。 Normalize 最大的特色就是保留原本預設 HTML 標籤的樣式，僅針對不同瀏覽器與各版本間不相容的標籤進行些微調整。 Normalize.css 的目標： 保留有用的瀏覽器默認設置，而不是將其刪除。為廣泛的 HTML 元素提供一般化的樣式。修正瀏覽器的 Bug 與不一致。透過微妙的改善提高可用性。有詳細的文檔來解釋代碼。(每個樣式都有註解是處理什麼問題。) http://nicolasgallagher.com/about-normalize-css/","link":"/2020/04/23/CSS-CSS-Reset-vs-CSS-normalize/"},{"title":"Front-end - 前端中的 MVVM 與 Vue.js","text":"MVVM（Model–view–viewmodel）是一種軟體架構模式，其核心是提供對 View 和 View Model 的雙向數據綁定，這使得 View Model 的狀態改變可以自動傳遞給 View，這就是所謂的數據雙向綁定。 MVVM？ 為什麼需要使用它？討論 MVVM 前，先稍微暸解 MVC 架構 Model 就是數據View 把數據以某種方式呈現給用戶Controller 接收並處理來自用戶的請求，並將 Model 返回給用戶 在 HTML5 出現前，MVC 做為 Web 應用的最佳實踐是沒問題的，這是因為 Web 應用的 View 層相對來說比較簡單，前端所需要的數據在後端基本上都可以處理好，View 層主要是做一下展示，那時候提倡的是 Controller 來處理複雜的業務邏輯，所以 View 層相對來說比較輕量。 在 HTML5 出現後，View 層所做的事，就不僅僅是簡單的數據展示了，要管理數據，管理用戶操作的各種狀態，還要處理移動設備上用戶各種操作行為等等。因此，前端自己也需要一個類似於 MVC 的框架來管理這些複雜的邏輯，使開發更加高效。 此時的 MVC 架構在前端開發中變成以下： Model 管理數據View UI 布局，展示數據Controller 響應用戶操作，並將 Model 更新到 View 上 這種 MVC 架構模式對於基礎的應用來看起是OK的，更是符合軟體架構的分層思想。 但實際上，隨著 H5 的不斷發展，人們更希望使用 H5 開發的應用能和 Native 媲美，或者接近於原生 App 體驗效果，於是前端應用的複雜程度已不同往日，今非昔比。這時前端就暴露了三個重要的痛點問題： 開發者在代碼中大量調用相同的 DOM API, 處理繁瑣 ，操作冗餘，使得代碼難以維護。 大量的 DOM 操作使頁面渲染性能降低，加載速度變慢，影響用戶體驗。 當 Model 頻繁發生變化，開發者需要主動更新到 View；當用戶的操作導致 Model 發生變化，開發者同樣需要將變化的數據同步到 Model 中， 這樣的工作不僅繁瑣，而且很難維護複雜多變的數據狀態。 MVVM 的出現，完美的解決了以上三個問題MVVM 由 Model,View,ViewModel 三部分組成，Model 層代表數據模型，也可以在 Model 中定義數據修改和操作的業務邏輯；View 代表 UI 組件，它負責將數據模型轉化成 UI 展現出來，ViewModel 是一個同步 View 和 Model的對象。 在MVVM架構下，View 和 Model 之間並沒有直接的聯繫，而是通過 ViewModel 進行交互，Model 和 ViewModel 之間的交互是雙向的， 因此View 數據的變化會同步到 Model 中，而 Model 數據的變化也會立即反應到 View 上。 ViewModel 通過雙向數據綁定把 View 層和 Model 層連接了起來，而 View 和 Model 之間的同步工作完全是自動的，無需人為干涉，因此開發者只需關注業務邏輯，不需要手動操作 DOM,不需要關注數據狀態的同步問題，複雜的數據狀態維護完全由 MVVM 來統一管理。 Vue.js 的細節Vue.js 可以說是前端框架中 MVVM 架構的最佳實踐，專注於 MVVM 中的 ViewModel，不僅做到了數據雙向綁定，而且也是一款相對來比較輕量級的 JS 庫，API 簡潔，很容易上手。 下面簡單了解一下 Vue.js 關於雙向綁定的一些實現細節： Vue.js 採用的是 Object.defineProperty 的 getter 和 setter，並結合觀察者模式來實現數據綁定的。當把一個普通 Javascript 對象傳給 Vue 實例來作為它的 data 選項時，Vue 將遍歷它的屬性，用 Object.defineProperty 將它們轉為 getter/setter。用戶看不到 getter/setters，但是在內部它們讓 Vue 追蹤依賴，在屬性被訪問和修改時通知變化。 Observer 數據監聽器，能夠對數據對象的所有屬性進行監聽，如有變動可拿到最新值並通知訂閱者，內部採用Object.defineProperty的getter和setter來實現Compile 指令解析器，它的作用對每個元素節點的指令進行掃描和解析，根據指令模板替換數據，以及綁定相應的更新函數Watcher 訂閱者， 作為連接 Observer 和 Compile 的橋樑，能夠訂閱並收到每個屬性變動的通知，執行指令綁定的相應回調函數Dep 消息訂閱器，內部維護了一個數組，用來收集訂閱者（Watcher），數據變動觸發notify 函數，再調用訂閱者的 update 方法 當執行 new Vue 時，Vue 就進入了初始化階段，一方面 Vue 會遍歷 data 選項中的屬性，並用 Object.defineProperty 將它們轉為 getter/setter，實現數據變化監聽功能；另一方面，Vue 的指令編譯器 Compile 對元素節點的指令進行掃描和解析，初始化視圖，並訂閱 Watcher 來更新視圖， 此時 Watcher 會將自己添加到消息訂閱器中(dep),初始化完畢。 當數據發生變化時，Observer 中的 setter方 法被觸發，setter 會立即調用 Dep.notify，Dep 開始遍歷所有的訂閱者，並調用訂閱者的 update 方法，訂閱者收到通知後對視圖進行相應的更新，完成一次數據綁定。 原文網址：https://www.cnblogs.com/onepixel/p/6034307.html","link":"/2020/04/23/Vue.js%20-%20MVVM/"},{"title":"CSS-BEM and 7-1 pattern","text":"BEM在網頁前端開發時，有時候我們會遇到一些 class 命名的問題，舉幾個例子： 比如頁面上有兩個頭像 avator，一個在 navbar 上，另外一個在文章標題旁邊，功能都是秀出頭像，只是樣式上的不同，class 就沒辦法都取為 avator。 撰寫 style 時，有時候需要來回對照現在寫的 \bclass 是在哪一個父元素下面，沒辦法看到 class 就知道他在網頁的哪個部分。 使用 Sass 時，有一個很棒的地方，就是它的巢狀結構，有沒有辦法讓他更簡潔，又一目瞭然。 有沒有一個 class 命名標準，可以一次解決上述的問題，有，那就是 BEM 了。 BEM 用元件化的觀念將整個頁面切分成不同區塊，更使得代碼擁有很好的重用性，主要分成 3 個等級： Block 區塊 Element 元素 Modifier 修飾 上面這個例子，可以很清楚的看到 class 開頭 recipe 就是他的 Block 元件本身，雙底線 _ _ 後面接這個 block 裡的元素，圖片框，詳細內容……，兩個連號 - - 後面接的是修飾，就是功能差不多，只有一點樣式不一樣，需要使用到不同的 class 時，我們會在 - - 後面加上他的描述，例如綠色按鈕 btn - - green。 BEM 命名規則 在 Sass 裡面，變得一目瞭然： 7-1 pattern 為了 Sass 的開發與維護更容易，把\b style 資料夾分成7種: base/ components/ layout/ pages/ themes/ abstracts/ vendors/ 7-1 pattern 很好的把 不同種類的 style 區分出來，避免了開發時單個 style 檔案過多行，找一個 selector 找老半天的窘境，也把一些共用的變數與接口放在專屬的 sass 檔，更輕鬆的管理整個專案的樣式。","link":"/2020/04/28/CSS-BEM-and-7-1pattern/"},{"title":"Sass - @extend 與 @Mixin 的差異","text":"什麼時候該用 @mixin ?@mixin 主要有兩個用途： 幫你把會重複用到的樣式統一做一個接口，方便後續維護。 還有可以帶入變數的特性，讓具重複性的代碼，可以更彈性的使用。 但是他並不是沒有成本，當你在高度重複的代碼裡使用 @mixin，在編譯過後，會發現其實他並沒有變得更精簡，他只是方便我們開發而已。 1234567891011121314151617181920212223242526272829303132333435363738@mixin title{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.sidebar h2{ @include title;}.content h4{ @include title;}.main h3{ @include title;}//編譯出來的CSS.sidebar h2{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.content h4{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.main h3{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;} 那有什麼方法可以既方便維護又不會編譯出來一大串重複的程式碼呢？這時候就輪到 @extend 出場了。 @extend@extend 主要是把重複樣式的 selector 集合在一起，就可以達到既方便維護又節省程式碼的效果： 12345678910111213141516171819202122232425// %title是css會被堆疊的位置%title{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.sidebar h2{ @extend %title}.content h4{ @extend %title}.main h3{ @extend %title}//編譯出來的CSS.sidebar h2,.content h4,.main h3{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}","link":"/2020/04/29/Sass-extend%20vs%20Mixin/"},{"title":"資料結構 x JavaScript -（1）陣列 Array","text":"陣列幾乎所有程式語言都具備陣列這個資料結構，以定義來說，他是由相同類型的元素（element）的集合所組成的資料結構，在一般程式語言中陣列只能儲存同樣型別的值，但在 JavaScript 則可以儲存不同型別的值（也應該盡量避免）。 優點： 資料存取查詢 by Random Access：在 Array 中只需要利用 index 即可對特定位置的資料作存取與查詢，此動作之時間複雜度為 O(1) 較 Linked list 節省記憶體空間：Linked List 需要額外的記憶體空間來儲存指到下一個 node 的 pointer 缺點： Array 的元素在記憶體中是連續儲存的，所以假設要新增或刪除 Array 的第1個位置的元素，則須將第2~last 位置的元素一一往前或往後搬動，時間複雜度為O(N)。 若資料數量時常在改變，要時常調整 Array的大小，也需花費O(N)時間在搬動資料。 使用時機 : 希望能夠快速存取查詢資料，時間複雜度只有O(1)。 已知欲處理的資料數量，便能確認 Array 的大小。 要求記憶體空間的使用越少越好。 陣列在 JavaScript 上的基本用法(1) 建立陣列 使用 new Array()，可以自定陣列大小123let newArr1 = new Array();let newArr2 = new Array(999);let students = new Array(&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;); 使用 [] 宣告陣列12let newArr1 = [];let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;]; (2) 新增、刪除陣列元素 暴力新增法，直接在陣列最後面添加元素123let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;];// 由於陣列 index 是從 0 開始，使用陣列長度當 index 賦值就會新增一個元素 students[students.length] = &apos;巨石強森&apos;; 使用 push、pop 新增或移除最後陣列元素：1234567let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;];// 將 巨石強森 加入最後元素 students.push(&apos;巨石強森&apos;); // [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;, &apos;巨石強森&apos;]// 將剛剛加入的 巨石強森 移除students.pop(); // [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;] 將元素插入陣列首位 和 移除首位的元素 unshift、shift ：1234567let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;];// 將 巨石強森 插入首位students.unshift(&apos;巨石強森&apos;); // [&apos;巨石強森&apos;, &apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;]// 將剛剛加入的 巨石強森 移除students.shift(); // [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;] (3) 二維陣列在 JavaScript 中只其實只支援一維陣列，但是可以用陣列嵌套陣列的方式來模擬多維陣列：12345678910let students = [];students[0] = [&apos;巨石強森&apos;, &apos;阿諾史瓦辛格&apos;];students[1] = [&apos;席維斯史特龍&apos;, &apos;馮迪索&apos;];// students = [[&apos;巨石強森&apos;, &apos;阿諾史瓦辛格&apos;], [&apos;席維斯史特龍&apos;, &apos;馮迪索&apos;]]for(let i = 0; i &lt; students.length; i++) { for(let j = 0; j &lt; students[i].length; j++) { console.log(students[i][j]); // 巨石強森 阿諾史瓦辛格 席維斯史特龍 馮迪索 }} (4) 常用陣列方法陣列迭代 forEach，單純對陣列每個元素都進行迭代123numbers.forEach(function(value, index){ console.log(value, index);}); map，對陣列每個元素都進行迭代並回傳新的陣列，不會改變原本陣列。1234567let numbers = [1, 2, 3, 4];let newNumbers = numbers.map(function(value, index) { return value + 1});console.log(numbers); // [1, 2, 3, 4]console.log(newNumbers); // [2, 3, 4, 5] every，對陣列每個元素都進行迭代，若迭代函數內容皆為 true，則回傳 true，反之回傳 false1234567let ages = [32, 33, 16, 40];function checkAdult(age) { return (age &gt;= 18) ? true : false;}console.log(ages.every(checkAdult)); // false some，若迭代函數中有一個為 true 即回傳 true，反之回傳 false1234567let ages = [3, 10, 18, 20];function checkAdult(age) { return (age &gt;= 18) ? true : false;}console.log(ages.some(checkAdult)); // true reduce，由左向右累加\b，參數有四個 previousValue,currentValue, index, array123456let numbers = [2, 3, 5, 6];function getSum(total, num) { return total + num;}console.log(numbers.reduce(getSum)); // 16 reduceRight，由右向左累加\b123456let numbers = [2, 3, 5, 6];function getSum(total, num) { return total + num;}console.log(numbers.reduce(getSum)); // 16 filter，依據條件回傳過濾後的陣列1234567let ages = [32, 33, 16, 40];function checkAdult(age) { return age &gt;= 18;}console.log(ages.filter(checkAdult)); // [32, 33, 40] 搜尋 indexOf，搜尋第一個匹配到的元素的 index12let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;, &apos;巨石強森&apos;];let a = students.indexOf(&apos;馮迪索&apos;); // 2 lastIndexOf，搜尋最後一個匹配到的元素的 index12let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;, &apos;巨石強森&apos;,&apos;馮迪索&apos;];let a = students.indexOf(&quot;Orange&quot;); // 4 排序 sort，將陣列內容進行排序，回傳排序後陣列，若為文字則根據 ASCII Code 編碼大小進行比較12let fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.sort(); // [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Mango&quot;, &quot;Orange&quot;] reverse，將陣列內容反轉12let fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.reverse(); // [&quot;Mango&quot;, &quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;] 陣列合併和切割 join，將陣列轉成字串，預設以分隔符號,串連成字串12345let fruits = [&apos;Banana&apos;, &apos;Orange&apos;, &apos;Lemon&apos;, &apos;Apple&apos;, &apos;Raspberry&apos;];console.log(fruits.join()); // Banana,Orange,Lemon,Apple,Raspberrylet fruits = [&apos;Banana&apos;, &apos;Orange&apos;, &apos;Lemon&apos;, &apos;Apple&apos;, &apos;Raspberry&apos;];console.log(fruits.join(&apos;&apos;)); // BananaOrangeLemonAppleRaspberry toString，回傳陣列轉成字串的結果，不會改變原本陣列，類似 join，但是只能用預設 , 做分隔12let fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.toString(); // Banana,Orange,Apple,Mango split，將字串轉成陣列12let a = &apos;1,2,3,4&apos;;console.log(a.split(&apos;,&apos;)); //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;] concat，合併陣列123let hege = [&quot;Cecilie&quot;, &quot;Leo&quot;];let stale = [&quot;Emil&quot;, &quot;May&quot;, &quot;Linus&quot;];console.log(hege.concat(stale)); // [&apos;Cecilie&apos;, &apos;Leo&apos;, &apos;Emil&apos;, &apos;May&apos;, &apos;Linus&apos;] slice，剪裁並回傳新的陣列12let fruits = [&apos;Banana&apos;, &apos;Orange&apos;, &apos;Lemon&apos;, &apos;Apple&apos;, &apos;Raspberry&apos;];console.log(fruits.slice(1, 3)); // [&apos;Orange&apos;, &apos;Lemon&apos;, &apos;Apple&apos;]","link":"/2020/05/11/data-structure-javascript-array/"},{"title":"資料結構 x JavaScript -（2）鏈結串列 Linked List","text":"鏈結串列 Linked List優點： 不需使用連續記憶體空間，不需事先指定串列大小 各節點資料型態並不一定要相同 能動態新增和刪除元素，只要對 O(1) 個 node 調整 pointer 所指向的 node 即可，不需要像 array 一樣搬動其餘元素。 若想在特定位置新增、刪除 node，只需要先作 O(N) 搜尋到特定 node 後，再作新增、刪除 node 的動作。 若是在 Linked List 的 head 新增 node，只需 O(1) 的時間複雜度。 缺點： 因 Linked List 沒有 index，若要存取查詢(access)特定 node 的資料，可能會需要從頭開始找，故 access 的搜尋時間複雜度為 O(N)。 需要額外的記憶體空間來儲存指到下一個 node 的 pointer。 使用時機： 無法預期資料數量時，使用linked list就沒有resize的問題。 需要頻繁地新增/刪除資料時。 不需要快速存取查詢資料時。 看看 JavaScript 如何實現鏈結串列(1) 建立鏈結串列123456789101112function LinkedList() { // 建立節點的結構，包含一個資料和指到下一個節點的 pointer const Node = function(element) { this.element = element; this.next = null; } // 存放 Linked List 長度 let length = 0; // 第一個節點的指標 let head = null;} (2) 建立鏈結串列的需要使用到的方法 append ，新增一個節點到連結串列的尾部 在尾部新增元素會有兩種可能： 串列為空：直接將 head 指向 null 改為指向新的節點 串列不為空：使用 current 當做輔助指標，先指到 head 指到的節點。使用 while 迴圈尋找到最後的節點（若 current.next 不為 null 代表後面還有節點，並將 current 指到下一個節點 current.next，不段重複，當 current.next 等於 null 時，已經到了最後節點，此時將 current.next 指到新增的 node，完成 append 12345678910111213141516171819202122function LinkedList() { //···以上省略··· this.append = function(element) { // new 一個新的節點 const node = new Node(element) let current; if(head === null) { // 第一種情況 head = node; } else { // 第二種情況 current = head; while(current.next) { current = current.next; } current.next = node; } // 更新串列長度 length++; };}","link":"/2020/05/12/data-structure-javascript-linked-list/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Sass","slug":"Sass","link":"/tags/Sass/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[{"name":"front-end","slug":"front-end","link":"/categories/front-end/"},{"name":"DataStructure","slug":"DataStructure","link":"/categories/DataStructure/"}]}