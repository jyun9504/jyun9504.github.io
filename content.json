{"pages":[],"posts":[{"title":"CSS - CSS Reset vs CSS Normalize","text":"CSS Reset因近年來各家瀏覽器陸續出現，更有新舊版本的差異，所以會產生不同的預設樣式，如默認行高，邊距和各元素字體大小等方面的不一致，一個統一的預設樣式開始變得越來越重要。 最簡單粗暴的做法就是直接把所有的預設樣式強制歸 0，比如： 123456* { margin: 0; padding: 0; border: 0; font-size: 100%;}但是通用符號會匹配所有的標籤，如果開發的是大型網站，會大大加重網頁渲染時間，所以最好還是只對需要的標籤做修改。 CSS-Tricks 調查最多人使用的 Eric Meyer 的版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, font, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td { margin: 0; padding: 0; border: 0; outline: 0; font-weight: inherit; font-style: inherit; font-size: 100%; font-family: inherit; vertical-align: baseline;}/* remember to define focus styles! */:focus { outline: 0;}body { line-height: 1; color: black; background: white;}ol, ul { list-style: none;}/* tables still need &apos;cellspacing=&quot;0&quot;&apos; in the markup */table { border-collapse: separate; border-spacing: 0;}caption, th, td { text-align: left; font-weight: normal;}blockquote:before, blockquote:after,q:before, q:after { content: &quot;&quot;;}blockquote, q { quotes: &quot;&quot; &quot;&quot;;}https://meyerweb.com/eric/tools/css/reset/ CSS Normalize因為 reset.css 重置了各個瀏覽器的樣式設定，使得有些有用、常用標籤的默認樣式必須要重新設定，因為這個問題，導致了 Normalize.css 的出現。 Normalize 最大的特色就是保留原本預設 HTML 標籤的樣式，僅針對不同瀏覽器與各版本間不相容的標籤進行些微調整。 Normalize.css 的目標： 保留有用的瀏覽器默認設置，而不是將其刪除。為廣泛的 HTML 元素提供一般化的樣式。修正瀏覽器的 Bug 與不一致。透過微妙的改善提高可用性。有詳細的文檔來解釋代碼。(每個樣式都有註解是處理什麼問題。) http://nicolasgallagher.com/about-normalize-css/","link":"/2020/04/23/CSS-CSS-Reset-vs-CSS-normalize/"},{"title":"Front-end - 前端中的 MVVM 與 Vue.js","text":"MVVM（Model–view–viewmodel）是一種軟體架構模式，其核心是提供對 View 和 View Model 的雙向數據綁定，這使得 View Model 的狀態改變可以自動傳遞給 View，這就是所謂的數據雙向綁定。 MVVM？ 為什麼需要使用它？討論 MVVM 前，先稍微暸解 MVC 架構 Model 就是數據View 把數據以某種方式呈現給用戶Controller 接收並處理來自用戶的請求，並將 Model 返回給用戶 在 HTML5 出現前，MVC 做為 Web 應用的最佳實踐是沒問題的，這是因為 Web 應用的 View 層相對來說比較簡單，前端所需要的數據在後端基本上都可以處理好，View 層主要是做一下展示，那時候提倡的是 Controller 來處理複雜的業務邏輯，所以 View 層相對來說比較輕量。 在 HTML5 出現後，View 層所做的事，就不僅僅是簡單的數據展示了，要管理數據，管理用戶操作的各種狀態，還要處理移動設備上用戶各種操作行為等等。因此，前端自己也需要一個類似於 MVC 的框架來管理這些複雜的邏輯，使開發更加高效。 此時的 MVC 架構在前端開發中變成以下： Model 管理數據View UI 布局，展示數據Controller 響應用戶操作，並將 Model 更新到 View 上 這種 MVC 架構模式對於基礎的應用來看起是OK的，更是符合軟體架構的分層思想。 但實際上，隨著 H5 的不斷發展，人們更希望使用 H5 開發的應用能和 Native 媲美，或者接近於原生 App 體驗效果，於是前端應用的複雜程度已不同往日，今非昔比。這時前端就暴露了三個重要的痛點問題： 開發者在代碼中大量調用相同的 DOM API, 處理繁瑣 ，操作冗餘，使得代碼難以維護。 大量的 DOM 操作使頁面渲染性能降低，加載速度變慢，影響用戶體驗。 當 Model 頻繁發生變化，開發者需要主動更新到 View；當用戶的操作導致 Model 發生變化，開發者同樣需要將變化的數據同步到 Model 中， 這樣的工作不僅繁瑣，而且很難維護複雜多變的數據狀態。 MVVM 的出現，完美的解決了以上三個問題MVVM 由 Model,View,ViewModel 三部分組成，Model 層代表數據模型，也可以在 Model 中定義數據修改和操作的業務邏輯；View 代表 UI 組件，它負責將數據模型轉化成 UI 展現出來，ViewModel 是一個同步 View 和 Model的對象。 在MVVM架構下，View 和 Model 之間並沒有直接的聯繫，而是通過 ViewModel 進行交互，Model 和 ViewModel 之間的交互是雙向的， 因此View 數據的變化會同步到 Model 中，而 Model 數據的變化也會立即反應到 View 上。 ViewModel 通過雙向數據綁定把 View 層和 Model 層連接了起來，而 View 和 Model 之間的同步工作完全是自動的，無需人為干涉，因此開發者只需關注業務邏輯，不需要手動操作 DOM,不需要關注數據狀態的同步問題，複雜的數據狀態維護完全由 MVVM 來統一管理。 Vue.js 的細節Vue.js 可以說是前端框架中 MVVM 架構的最佳實踐，專注於 MVVM 中的 ViewModel，不僅做到了數據雙向綁定，而且也是一款相對來比較輕量級的 JS 庫，API 簡潔，很容易上手。 下面簡單了解一下 Vue.js 關於雙向綁定的一些實現細節： Vue.js 採用的是 Object.defineProperty 的 getter 和 setter，並結合觀察者模式來實現數據綁定的。當把一個普通 Javascript 對象傳給 Vue 實例來作為它的 data 選項時，Vue 將遍歷它的屬性，用 Object.defineProperty 將它們轉為 getter/setter。用戶看不到 getter/setters，但是在內部它們讓 Vue 追蹤依賴，在屬性被訪問和修改時通知變化。 Observer 數據監聽器，能夠對數據對象的所有屬性進行監聽，如有變動可拿到最新值並通知訂閱者，內部採用Object.defineProperty的getter和setter來實現Compile 指令解析器，它的作用對每個元素節點的指令進行掃描和解析，根據指令模板替換數據，以及綁定相應的更新函數Watcher 訂閱者， 作為連接 Observer 和 Compile 的橋樑，能夠訂閱並收到每個屬性變動的通知，執行指令綁定的相應回調函數Dep 消息訂閱器，內部維護了一個數組，用來收集訂閱者（Watcher），數據變動觸發notify 函數，再調用訂閱者的 update 方法 當執行 new Vue 時，Vue 就進入了初始化階段，一方面 Vue 會遍歷 data 選項中的屬性，並用 Object.defineProperty 將它們轉為 getter/setter，實現數據變化監聽功能；另一方面，Vue 的指令編譯器 Compile 對元素節點的指令進行掃描和解析，初始化視圖，並訂閱 Watcher 來更新視圖， 此時 Watcher 會將自己添加到消息訂閱器中(dep),初始化完畢。 當數據發生變化時，Observer 中的 setter方 法被觸發，setter 會立即調用 Dep.notify，Dep 開始遍歷所有的訂閱者，並調用訂閱者的 update 方法，訂閱者收到通知後對視圖進行相應的更新，完成一次數據綁定。 原文網址：https://www.cnblogs.com/onepixel/p/6034307.html","link":"/2020/04/23/Vue.js%20-%20MVVM/"},{"title":"CSS-BEM and 7-1 pattern","text":"BEM在網頁前端開發時，有時候我們會遇到一些 class 命名的問題，舉幾個例子： 比如頁面上有兩個頭像 avator，一個在 navbar 上，另外一個在文章標題旁邊，功能都是秀出頭像，只是樣式上的不同，class 就沒辦法都取為 avator。 撰寫 style 時，有時候需要來回對照現在寫的 \bclass 是在哪一個父元素下面，沒辦法看到 class 就知道他在網頁的哪個部分。 使用 Sass 時，有一個很棒的地方，就是它的巢狀結構，有沒有辦法讓他更簡潔，又一目瞭然。 有沒有一個 class 命名標準，可以一次解決上述的問題，有，那就是 BEM 了。 BEM 用元件化的觀念將整個頁面切分成不同區塊，更使得代碼擁有很好的重用性，主要分成 3 個等級： Block 區塊 Element 元素 Modifier 修飾 上面這個例子，可以很清楚的看到 class 開頭 recipe 就是他的 Block 元件本身，雙底線 _ _ 後面接這個 block 裡的元素，圖片框，詳細內容……，兩個連號 - - 後面接的是修飾，就是功能差不多，只有一點樣式不一樣，需要使用到不同的 class 時，我們會在 - - 後面加上他的描述，例如綠色按鈕 btn - - green。 BEM 命名規則 在 Sass 裡面，變得一目瞭然： 7-1 pattern 為了 Sass 的開發與維護更容易，把\b style 資料夾分成7種: base/ components/ layout/ pages/ themes/ abstracts/ vendors/ 7-1 pattern 很好的把 不同種類的 style 區分出來，避免了開發時單個 style 檔案過多行，找一個 selector 找老半天的窘境，也把一些共用的變數與接口放在專屬的 sass 檔，更輕鬆的管理整個專案的樣式。","link":"/2020/04/28/CSS-BEM-and-7-1pattern/"},{"title":"Sass - @extend 與 @Mixin 的差異","text":"什麼時候該用 @mixin ?@mixin 主要有兩個用途： 幫你把會重複用到的樣式統一做一個接口，方便後續維護。 還有可以帶入變數的特性，讓具重複性的代碼，可以更彈性的使用。 但是他並不是沒有成本，當你在高度重複的代碼裡使用 @mixin，在編譯過後，會發現其實他並沒有變得更精簡，他只是方便我們開發而已。 1234567891011121314151617181920212223242526272829303132333435363738@mixin title{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.sidebar h2{ @include title;}.content h4{ @include title;}.main h3{ @include title;}//編譯出來的CSS.sidebar h2{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.content h4{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.main h3{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;} 那有什麼方法可以既方便維護又不會編譯出來一大串重複的程式碼呢？這時候就輪到 @extend 出場了。 @extend@extend 主要是把重複樣式的 selector 集合在一起，就可以達到既方便維護又節省程式碼的效果： 12345678910111213141516171819202122232425// %title是css會被堆疊的位置%title{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}.sidebar h2{ @extend %title}.content h4{ @extend %title}.main h3{ @extend %title}//編譯出來的CSS.sidebar h2,.content h4,.main h3{ font-size:18px; line-height:1.8; border-bottom: 3px solid #000; border-left:3px solid #000; padding: 0 0 0 30px;}","link":"/2020/04/29/Sass-extend%20vs%20Mixin/"},{"title":"資料結構 x JavaScript -（1）陣列 Array","text":"陣列幾乎所有程式語言都具備陣列這個資料結構，以定義來說，他是由相同類型的元素（element）的集合所組成的資料結構，在一般程式語言中陣列只能儲存同樣型別的值，但在 JavaScript 則可以儲存不同型別的值（也應該盡量避免）。 優點： 資料存取查詢 by Random Access：在 Array 中只需要利用 index 即可對特定位置的資料作存取與查詢，此動作之時間複雜度為 O(1) 較 Linked list 節省記憶體空間：Linked List 需要額外的記憶體空間來儲存指到下一個 node 的 pointer 缺點： Array 的元素在記憶體中是連續儲存的，所以假設要新增或刪除 Array 的第1個位置的元素，則須將第2~last 位置的元素一一往前或往後搬動，時間複雜度為O(N)。 若資料數量時常在改變，要時常調整 Array的大小，也需花費O(N)時間在搬動資料。 使用時機 : 希望能夠快速存取查詢資料，時間複雜度只有O(1)。 已知欲處理的資料數量，便能確認 Array 的大小。 要求記憶體空間的使用越少越好。 陣列在 JavaScript 上的基本用法(1) 建立陣列 使用 new Array()，可以自定陣列大小123let newArr1 = new Array();let newArr2 = new Array(999);let students = new Array(&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;); 使用 [] 宣告陣列12let newArr1 = [];let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;]; (2) 新增、刪除陣列元素 暴力新增法，直接在陣列最後面添加元素123let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;];// 由於陣列 index 是從 0 開始，使用陣列長度當 index 賦值就會新增一個元素 students[students.length] = &apos;巨石強森&apos;; 使用 push、pop 新增或移除最後陣列元素：1234567let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;];// 將 巨石強森 加入最後元素 students.push(&apos;巨石強森&apos;); // [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;, &apos;巨石強森&apos;]// 將剛剛加入的 巨石強森 移除students.pop(); // [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;] 將元素插入陣列首位 和 移除首位的元素 unshift、shift ：1234567let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;];// 將 巨石強森 插入首位students.unshift(&apos;巨石強森&apos;); // [&apos;巨石強森&apos;, &apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;]// 將剛剛加入的 巨石強森 移除students.shift(); // [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;] (3) 二維陣列在 JavaScript 中只其實只支援一維陣列，但是可以用陣列嵌套陣列的方式來模擬多維陣列：12345678910let students = [];students[0] = [&apos;巨石強森&apos;, &apos;阿諾史瓦辛格&apos;];students[1] = [&apos;席維斯史特龍&apos;, &apos;馮迪索&apos;];// students = [[&apos;巨石強森&apos;, &apos;阿諾史瓦辛格&apos;], [&apos;席維斯史特龍&apos;, &apos;馮迪索&apos;]]for(let i = 0; i &lt; students.length; i++) { for(let j = 0; j &lt; students[i].length; j++) { console.log(students[i][j]); // 巨石強森 阿諾史瓦辛格 席維斯史特龍 馮迪索 }} (4) 常用陣列方法陣列迭代 forEach，單純對陣列每個元素都進行迭代123numbers.forEach(function(value, index){ console.log(value, index);}); map，對陣列每個元素都進行迭代並回傳新的陣列，不會改變原本陣列。1234567let numbers = [1, 2, 3, 4];let newNumbers = numbers.map(function(value, index) { return value + 1});console.log(numbers); // [1, 2, 3, 4]console.log(newNumbers); // [2, 3, 4, 5] every，對陣列每個元素都進行迭代，若迭代函數內容皆為 true，則回傳 true，反之回傳 false1234567let ages = [32, 33, 16, 40];function checkAdult(age) { return (age &gt;= 18) ? true : false;}console.log(ages.every(checkAdult)); // false some，若迭代函數中有一個為 true 即回傳 true，反之回傳 false1234567let ages = [3, 10, 18, 20];function checkAdult(age) { return (age &gt;= 18) ? true : false;}console.log(ages.some(checkAdult)); // true reduce，由左向右累加\b，參數有四個 previousValue,currentValue, index, array123456let numbers = [2, 3, 5, 6];function getSum(total, num) { return total + num;}console.log(numbers.reduce(getSum)); // 16 reduceRight，由右向左累加\b123456let numbers = [2, 3, 5, 6];function getSum(total, num) { return total + num;}console.log(numbers.reduce(getSum)); // 16 filter，依據條件回傳過濾後的陣列1234567let ages = [32, 33, 16, 40];function checkAdult(age) { return age &gt;= 18;}console.log(ages.filter(checkAdult)); // [32, 33, 40] 搜尋 indexOf，搜尋第一個匹配到的元素的 index12let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;, &apos;巨石強森&apos;];let a = students.indexOf(&apos;馮迪索&apos;); // 2 lastIndexOf，搜尋最後一個匹配到的元素的 index12let students = [&apos;阿諾史瓦辛格&apos;, &apos;席維斯史特龍&apos;, &apos;馮迪索&apos;, &apos;巨石強森&apos;,&apos;馮迪索&apos;];let a = students.indexOf(&quot;Orange&quot;); // 4 排序 sort，將陣列內容進行排序，回傳排序後陣列，若為文字則根據 ASCII Code 編碼大小進行比較12let fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.sort(); // [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Mango&quot;, &quot;Orange&quot;] reverse，將陣列內容反轉12let fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.reverse(); // [&quot;Mango&quot;, &quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;] 陣列合併和切割 join，將陣列轉成字串，預設以分隔符號,串連成字串12345let fruits = [&apos;Banana&apos;, &apos;Orange&apos;, &apos;Lemon&apos;, &apos;Apple&apos;, &apos;Raspberry&apos;];console.log(fruits.join()); // Banana,Orange,Lemon,Apple,Raspberrylet fruits = [&apos;Banana&apos;, &apos;Orange&apos;, &apos;Lemon&apos;, &apos;Apple&apos;, &apos;Raspberry&apos;];console.log(fruits.join(&apos;&apos;)); // BananaOrangeLemonAppleRaspberry toString，回傳陣列轉成字串的結果，不會改變原本陣列，類似 join，但是只能用預設 , 做分隔12let fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.toString(); // Banana,Orange,Apple,Mango split，將字串轉成陣列12let a = &apos;1,2,3,4&apos;;console.log(a.split(&apos;,&apos;)); //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;] concat，合併陣列123let hege = [&quot;Cecilie&quot;, &quot;Leo&quot;];let stale = [&quot;Emil&quot;, &quot;May&quot;, &quot;Linus&quot;];console.log(hege.concat(stale)); // [&apos;Cecilie&apos;, &apos;Leo&apos;, &apos;Emil&apos;, &apos;May&apos;, &apos;Linus&apos;] slice，剪裁並回傳新的陣列12let fruits = [&apos;Banana&apos;, &apos;Orange&apos;, &apos;Lemon&apos;, &apos;Apple&apos;, &apos;Raspberry&apos;];console.log(fruits.slice(1, 3)); // [&apos;Orange&apos;, &apos;Lemon&apos;, &apos;Apple&apos;]","link":"/2020/05/11/data-structure-javascript-array/"},{"title":"資料結構 x JavaScript -（2）鏈結串列 Linked List","text":"鏈結串列 Linked List優點： 不需使用連續記憶體空間，不需事先指定串列大小 各節點資料型態並不一定要相同 能動態新增和刪除元素，只要對 O(1) 個 node 調整 pointer 所指向的 node 即可，不需要像 array 一樣搬動其餘元素。 若想在特定位置新增、刪除 node，只需要先作 O(N) 搜尋到特定 node 後，再作新增、刪除 node 的動作。 若是在 Linked List 的 head 新增 node，只需 O(1) 的時間複雜度。 缺點： 因 Linked List 沒有 index，若要存取查詢(access)特定 node 的資料，可能會需要從頭開始找，故 access 的搜尋時間複雜度為 O(N)。 需要額外的記憶體空間來儲存指到下一個 node 的 pointer。 使用時機： 無法預期資料數量時，使用 Linked List 就沒有 resize 的問題。 需要頻繁地新增/刪除資料時。 不需要快速存取查詢資料時。 看看 JavaScript 如何實現鏈結串列(1) 建立鏈結串列123456789101112function LinkedList() { // 建立節點的結構，包含一個資料和指到下一個節點的 pointer const Node = function(element) { this.element = element; this.next = null; } // 存放 Linked List 長度 let length = 0; // 第一個節點的指標 let head = null;} (2) 建立鏈結串列需要使用到的方法append ，新增一個節點到連結串列的尾部在尾部新增元素會有兩種可能： 串列為空：直接將 head 指向 null 改為指向新的節點 串列不為空：使用 current 當做輔助指標，先指到 head 指到的節點。使用 while 迴圈尋找到最後的節點（若 current.next 不為 null 代表後面還有節點，並將 current 指到下一個節點 current.next，不段重複，當 current.next 等於 null 時，已經到了最後節點，此時將 current.next 指到新增的 node，完成 append 12345678910111213141516171819202122function LinkedList() { //···以上省略··· this.append = function(element) { // new 一個新的節點 const node = new Node(element) let current; if(head === null) { // 第一種情況 head = node; } else { // 第二種情況 current = head; while(current.next) { current = current.next; } current.next = node; } // 更新串列長度 length++; };} 實際使用新增方法： 123const lsit = new LinkedList();lsit.append(&apos;Mark&apos;);lsit.append(&apos;Jack&apos;); removeAt，從鏈結串列中移除元素刪除元素節點同樣有兩種情況： 移除第一個元素：直接讓 head 指向 current.next，就可以刪除第一個元素 移除除了第一個元素的其他元素：透過 while 迴圈搭配 index 可以讓 previous 指到欲刪除的元素的前一個節點。把欲刪除的節點的前一個節點改為指到 current.next 也就是欲刪除節點的下一個節點（若是尾端則是 null），就會刪除掉 current 節點 以上兩種情況都可以透過 JavaScript 的垃圾回收處理機制讓未被指到元素被資源回收掉1234567891011121314151617181920212223242526this.removeAt = function(position) { // 先判斷要移除元素的位置是否有效，是否大於 -1 小於長度 if(position &gt; -1 &amp;&amp; position &lt; length) { // 定義目前指到的 node， let current = head; let previous; let index = 0; if(position === 0) { // 讓 head 指向 current.next，就可以刪除第一個元素 head = current.next; } else { while(index++ &lt; position) { // 透過增加 index 讓 previous 指到欲刪除的元素的前一個節點 previous = current; // current 指到欲刪除的節點 current = current.next; } // 當欲刪除的節點的前一個節點指到 current.next 也就是欲刪除節點的下一個節點（若是尾端則是 null），就會刪除掉 current 節點 previous.next = current.next; } length--; return current.element; } else { return null; }} insert，在任意位置中插入元素123456789101112131415161718192021222324252627this.insert = function(position, element) { // 一樣先判斷要輸入的位置是否存在 if(position &gt;= 0 &amp;&amp; position &lt;= length) { let node = new Node(element); let current = head; let previous; let index = 0; // 如果是插入第一個 head 位置，直接把輸入的 node 指向當前節點 head，然後把 head 改為插入的節點 if(position === 0) { node.next = current; head = node; } else { // 移動到要插入的位置，並找到 previous while(index++ &lt; position) { previous = current; current = current.next; } //改變指標 node.next = current; previous.next = node; } length++; return true; } else { return false; }} 其他方法toString()，透過 while 迴圈把 LinkedList 物件內容轉換成字串123456789101112this.toString = function() { // 建立一個變數幫助迴圈 let current = head; let string = &apos;&apos;; // 循序檢查 current 指到的 node 是否存在，若存在則串接資料內容成字串 while(current) { string += current.element; // 指到下一個元素 current = current.next; } return string;} indexOf(element)，若傳入 element 在串列中則回傳其 index，若無則返回 -11234567891011121314this.indexOf = function(element) { var current = head; var index = -1; while(current) { // 循序尋找若找到則回傳 index if(element === current.element) { return index; } index++; current = current.next; } return -1;}; remove(element)，透過整合 indexOf 和 removeAt，我們可以更彈性刪除我們想要刪除的元素1234this.remove = function(element) { let index = this.indexOf(element); return this.removeAt(index);} isEmpty()，確認串列是否為空，若空返回 true，反之傳回 false123this.isEmpty = function() { return length === 0;} size()，回傳串列長度123this.size = function() { return length;} getHead()，回傳 private 變數 head123this.getHead = function() { return head;}","link":"/2020/05/12/data-structure-javascript-linked-list/"},{"title":"Coding Problems - Google 工程師 Coding 面試範例","text":"How to: Work at Google — Example Coding/Engineering InterviewLINK： https://www.youtube.com/watch?v=XKu_SEDAykw 從影片中學到什麼這個影片主要介紹 Google 在 coding interview 環節的模擬情況，最大的重點在於如何解題，可以用什麼樣的流程清楚展現自己如何解決問題，除了題目結果外，最重要的是解題過程中如何思考，整個流程可以細分成： 面試官闡述問題，在上面（i.e. sorted array）寫下 key points，確保所有細節，展示組織能力 在次確認 inputs outputs 思考問題重點是什麼，有時間空間內存的限制嗎 用最簡單/暴力解法開始解題，口頭描述，表明出你善於思考與批判 說明這個解法不是最佳解，它的 bigO，readable 說明 code 有什麼地方是多餘的，重複的，可以怎麼去解決 在真正開始寫下代碼前，先在問題上寫下我要怎麼做 開始將代碼模塊化，把代碼分成小片段，需要時寫下註解 真正寫下解法，前面準備得越多，能寫下的代碼就越好，千萬不要不確定怎麼寫就開始 思考程式什麼情況下會出錯，假設有人想要破壞你的程式碼，什麼樣的 inputs 會導致程式出錯，告訴面試官我會怎麼測試這段程式碼 命名盡量用人看得懂的 告訴面試官你會怎麼加強你的代碼，有沒有辦法更 readable，會怎麼使用 google 來幫助你 在這個範例題目我用 JavaScript 實作一次Question：輸入數列，裡面的數字兩兩相加，等於8的話回傳 true[1,2,3,9] if sum = 8 return false[1,2,4,4] if sum = 8 return true 釐清問題後首先以暴力解法 run 一遍，完全遍歷整個陣列 12345678910111213const arr1 = [1, 2, 3, 9];const arr2 = [1, 2, 4, 4];function checkSumEqual(arr) { for(let i = 0; i &lt; arr.length - 1; i++){ for(let j = 0; j &lt; arr.length - 1; j++){ if(arr[i] + arr[j] == 8) return true } } return false};console.log(checkSumEqual(arr2)); 可以發現這種解法的時間複雜度是 Ｏ(n^2)，而且會有重複相加的情形，開始思考有什麼方式可以不會重複相加，可能會想到使用類似 Selection Sort 把第二層迴圈 j 初始值從 0 改為 i，解決了重複相加的問題，相比原本來說好了一點，但是還是一樣使用了兩層的迴圈，時間複雜度一樣是 Ｏ(n^2)，所以在思考看看有沒有其他方法。在影片裡被面試者想到的是縮小範圍的方式，最大值加最小值，如果大於 8，最大值 index - 1，反之如果小於 8 就讓最小值 index + 1，如果中間遇到相加等於 8 就直接回傳 true，迴圈到最小值 &gt; 最大值為止 1234567891011121314151617181920const arr1 = [1, 2, 3, 9];const arr2 = [1, 2, 4, 4];function checkSumEqual(arr) { let min = 0; let max = arr.length - 1; while(min &lt; max){ let s = arr[min] + arr[max]; if(s == 8){ return true }else if(s &gt; 8){ max--; }else{ min++; } } return false};console.log(checkSumEqual(arr2)); 看似完美的解決問題，只有使用到一個迴圈，時間複雜度 Ｏ(n)，但是在這裡面試官丟出一個難題，不保證輸入的值有經過排序，所以這個解法行不通了，如果還要做排序那可能效能還沒有暴力解好，所以還要再看看有什麼方式，可能會想到 hash table 的方式，做一次遍歷，把 8 減掉現在遍歷到的數字放到 hash 表中，如果現在遍歷到的數字匹配到 hash 的數字，就代表有一對數字相加為 8，回傳 true 12345678910111213const arr1 = [1, 2, 3, 9];const arr2 = [1, 2, 4, 4];function checkSumEqual(arr) { let hashTable = new Set(); for(i = 0; i &lt; arr.length; i++){ if(hashTable.has(arr[i])) return true hashTable.add(8 - arr[i]) } return false}console.log(checkSumEqual(arr2)); 這樣解決了遍歷一次，時間複雜度O(n)，而且不會有排序問題，因為 HashTable 是慢慢把前面遍歷的值處理後加進去，也不會有自己加自己的狀況產生，很好的解法。 最後到這裡就告一段落了，可能還會再問一些相關問題，比如輸入的數字太多，無法負荷，你會用什麼方法解決，這邊就是把自己的想法講出來就好了，可能是把輸入分段處理，分段處理又會遇到什麼問題……","link":"/2020/05/15/coding-problems-google-coding-interview-example/"},{"title":"JavaScript Value vs. Reference","text":"在 JavaScript 環境中，如果你輸入：12console.log( [] == [] );console.log( {} == {} ); 兩個 log 得到的會是 true 還是 false ?答案都是： false 再來看看其他例子123456var object1 = {value: 10};var object2 = object1;var object3 = {value: 10};console.log(object1 == object2); // trueconsole.log(object1 == object3); // false 為什麼 object1 跟 object3 裡面的值一樣，卻不相等？JavaScript 的 物件 與 一般變數 在存取時，是有不同的機制的，一般變數不論是 字串、Number、Boolean、Null…，變數在賦值時，指向的是它的 Value，Value 相等比較出來結果也會相等，而 Object 就不同了，在宣告一個變數是 Object 或 Array 時，等於是創建了一個獨一無二的空間，拿兩個不同的空間比較，結果當然也就是 false 結論所以在 JavaScript 中，比較兩者是否相同前，也要注意比較的兩方是 by Value 還是 by Reference","link":"/2020/05/18/javascript-value-vs-refrerence/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Sass","slug":"Sass","link":"/tags/Sass/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[{"name":"front-end","slug":"front-end","link":"/categories/front-end/"},{"name":"DataStructure","slug":"DataStructure","link":"/categories/DataStructure/"},{"name":"CodingProblems","slug":"CodingProblems","link":"/categories/CodingProblems/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}